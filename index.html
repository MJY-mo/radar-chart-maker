<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>画像放り込みレーダーチャートメーカー</title>
    <link rel="icon" href="favicon3.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,wght@0,400;0,700;1,400;1,700&family=Lobster&family=Merriweather:ital,wght@0,400;0,700;1,400;1,700&family=Noto+Sans+JP:wght@400;700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <style>
        /* カスタムスタイル */
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background-color: #f0f2f5;
            overscroll-behavior: none;
        }
        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .left-panel {
            width: 350px;
            flex-shrink: 0;
            background-color: white;
            height: 100vh;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #e2e8f0;
        }
        .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow-y: auto;
        }
        #canvas-container {
            flex-grow: 1;
            background-color: white;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            border: 3px dashed transparent;
            transition: border-color 0.3s, background-color 0.3s;
            padding: 1.5rem; /* コンテナ内の余白を追加 */
            margin: auto;
            width: 100%;
            max-width: 810px;
            max-height: 810px;
        }
        #canvas-container.drag-over {
            border-color: #4f46e5;
            background-color: #eef2ff;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            max-width: 90%;
            width: 500px;
        }
        canvas {
            cursor: crosshair;
        }
        .label-input {
            position: absolute;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        #help-view ul {
            list-style-type: disc;
            padding-left: 1.5rem;
        }
        #help-view li {
            margin-bottom: 0.5rem;
        }
        #help-view strong {
            color: #4F46E5;
        }
        .menu-btn {
            background-color: #6b7280; /* gray-500 */
            color: white;
        }
        .menu-btn:hover {
            background-color: #4b5563; /* gray-600 */
        }
        .menu-btn.active-help {
            background-color: #10b981; /* green-500 */
        }
        .menu-btn.active-help:hover {
            background-color: #059669; /* green-600 */
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .accordion-content {
            transition: max-height 0.3s ease-out;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div class="app-container">
    <!-- 左側設定パネル -->
    <aside class="left-panel">
        <div class="p-6 border-b">
            <div id="panel-header" class="flex justify-between items-center">
                <h2 id="panel-title" class="text-2xl font-bold"></h2>
                <button id="back-to-settings-btn" class="hidden bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg transition-colors"><i class="fas fa-arrow-left mr-2"></i><span data-lang="back_to_settings">戻る</span></button>
            </div>
        </div>

        <div class="panel-content">
            <!-- 設定ビュー -->
            <div id="settings-view" class="space-y-4">
                <!-- フィールド設定 -->
                <div>
                    <button id="field-settings-toggle" class="w-full flex justify-between items-center p-3 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors">
                        <span class="font-semibold" data-lang="fieldSettingsTitle">フィールド設定</span>
                        <i class="fas fa-chevron-up transition-transform"></i>
                    </button>
                    <div id="field-settings-content" class="accordion-content mt-4 space-y-6 pl-4 border-l-2 border-gray-200">
                        <div>
                            <label class="block text-sm font-medium text-gray-700" data-lang="labelAspectRatio">フィールドサイズ</label>
                            <div class="mt-2 flex space-x-4">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="aspectRatio" value="square" class="form-radio">
                                    <span class="ml-2" data-lang="aspectRatioSquare">正方形</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="aspectRatio" value="landscape">
                                    <span class="ml-2" data-lang="aspectRatioLandscape">横長</span>
                                </label>
                            </div>
                        </div>
                        <div>
                            <label for="sides" class="block text-sm font-medium text-gray-700"><span data-lang="labelSides">ステータス項目の数</span>: <span id="sides-value">5</span><span data-lang="sidesUnit"></span></label>
                            <input type="range" id="sides" min="4" max="7" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div>
                            <label for="maxValue" class="block text-sm font-medium text-gray-700"><span data-lang="labelMaxValue">ステータスの最大値</span>: <span id="maxValue-value">5</span></label>
                            <input type="range" id="maxValue" min="4" max="10" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="grid grid-cols-2 gap-4 items-center">
                            <div>
                                <label for="gridLineWidth" class="block text-sm font-medium text-gray-700"><span data-lang="labelGridLineWidth">枠線の太さ</span>: <span id="gridLineWidth-value">1</span>px</label>
                                <input type="range" id="gridLineWidth" min="0" max="5" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <div>
                                <label for="gridLineColor" class="block text-sm font-medium text-gray-700 sr-only" data-lang="labelGridLineColor">枠線の色</label>
                                <input type="color" id="gridLineColor" value="#CCCCCC" class="w-full h-10 p-1 border border-gray-300 rounded-lg cursor-pointer">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4 items-center">
                            <div>
                                <label for="labelFontSize" class="block text-sm font-medium text-gray-700"><span data-lang="labelLabelFontSize">項目文字サイズ</span>: <span id="labelFontSize-value">20</span>px</label>
                                <input type="range" id="labelFontSize" min="1" max="60" value="20" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                             <div>
                                <label for="labelColor" class="block text-sm font-medium text-gray-700 sr-only" data-lang="labelColor">項目文字の色</label>
                                <input type="color" id="labelColor" value="#333333" class="w-full h-10 p-1 border border-gray-300 rounded-lg cursor-pointer">
                            </div>
                        </div>
                        <button id="reset-field-settings-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm"><i class="fas fa-undo mr-2"></i><span data-lang="btnResetFieldSettings">フィールド設定をリセット</span></button>
                    </div>
                </div>

                <!-- チャート設定 -->
                <div>
                    <button id="chart-settings-toggle" class="w-full flex justify-between items-center p-3 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors">
                        <span class="font-semibold" data-lang="chartSettingsTitle">チャート設定</span>
                        <i class="fas fa-chevron-up transition-transform"></i>
                    </button>
                    <div id="chart-settings-content" class="accordion-content mt-4 space-y-6 pl-4 border-l-2 border-gray-200">
                        <div class="grid grid-cols-2 gap-4 items-center">
                            <div>
                                <label for="chartLineWidth" class="block text-sm font-medium text-gray-700"><span data-lang="labelChartLineWidth">チャート線の太さ</span>: <span id="chartLineWidth-value">2</span>px</label>
                                <input type="range" id="chartLineWidth" min="1" max="10" value="2" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <div>
                                <label for="chartLineColor" class="block text-sm font-medium text-gray-700 sr-only" data-lang="labelChartLineColor">チャート線の色</label>
                                <input type="color" id="chartLineColor" value="#000000" class="w-full h-10 p-1 border border-gray-300 rounded-lg cursor-pointer">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4 items-center">
                             <div>
                                <label for="fillOpacity" class="block text-sm font-medium text-gray-700"><span data-lang="labelFillOpacity">塗りつぶしの透過度</span>: <span id="fillOpacity-value">30</span>%</label>
                                <input type="range" id="fillOpacity" min="0" max="100" value="30" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <div>
                                <label for="fillColor" class="block text-sm font-medium text-gray-700 sr-only" data-lang="labelFillColor">チャートの塗りつぶしの色</label>
                                <input type="color" id="fillColor" value="#000000" class="w-full h-10 p-1 border border-gray-300 rounded-lg cursor-pointer">
                            </div>
                        </div>
                         <button id="reset-chart-settings-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm"><i class="fas fa-undo mr-2"></i><span data-lang="btnResetChartSettings">チャート設定をリセット</span></button>
                    </div>
                </div>
            </div>

            <!-- ヘルプビュー -->
            <div id="help-view" class="hidden text-sm text-gray-700 space-y-4"></div>

            <!-- 編集ビュー -->
            <div id="edit-view" class="hidden">
                 <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700" data-lang="labelEditMode">編集モード</label>
                        <select id="editMode" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                            <option value="image" data-lang="optionImage">画像</option>
                            <option value="text" data-lang="optionText">テキスト</option>
                        </select>
                    </div>
                    <!-- 画像編集用 -->
                    <div id="image-controls" class="space-y-4">
                        <div>
                            <label for="imageClip" class="block text-sm font-medium text-gray-700" data-lang="labelImageClip">画像表示方法</label>
                            <select id="imageClip" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                <option value="data" data-lang="clipData">チャート形状にクリップ</option>
                                <option value="frame" data-lang="clipFrame">グラフの枠にクリップ</option>
                                <option value="full" data-lang="clipFull">全体表示</option>
                            </select>
                        </div>
                        <div>
                            <label for="imageScale" class="block text-sm font-medium text-gray-700"><span data-lang="labelScale">拡大縮小</span>: <span id="imageScale-value">100</span>%</label>
                            <input type="range" id="imageScale" min="20" max="300" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div>
                            <label for="imageOpacity" class="block text-sm font-medium text-gray-700"><span data-lang="labelOpacity">透過度</span>: <span id="imageOpacity-value">100</span>%</label>
                            <input type="range" id="imageOpacity" min="0" max="100" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700" data-lang="labelPosition">位置（横/縦）</label>
                            <label for="imageOffsetX" class="block text-xs text-gray-500"><span data-lang="labelOffsetX">横</span>: <span id="imageOffsetX-value">0</span>px</label>
                            <input type="range" id="imageOffsetX" min="-200" max="200" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div>
                            <label for="imageOffsetY" class="block text-xs text-gray-500"><span data-lang="labelOffsetY">縦</span>: <span id="imageOffsetY-value">0</span>px</label>
                            <input type="range" id="imageOffsetY" min="-200" max="200" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    <!-- テキスト編集用 -->
                    <div id="text-controls" class="hidden space-y-4">
                        <div>
                            <label for="textValue" class="block text-sm font-medium text-gray-700" data-lang="textContent">テキスト内容</label>
                            <textarea id="textValue" class="w-full h-24 border border-gray-300 rounded-md p-2 mt-1"></textarea>
                        </div>
                         <div>
                            <label for="textFontFamily" class="block text-sm font-medium text-gray-700" data-lang="textFontFamily">フォント</label>
                            <select id="textFontFamily" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                <option value="Inter, 'Noto Sans JP', sans-serif">Inter (ゴシック)</option>
                                <option value="Roboto, sans-serif">Roboto (ゴシック)</option>
                                <option value="Merriweather, 'Noto Serif JP', serif">Merriweather (明朝)</option>
                                <option value="Lobster, cursive">Lobster (デザイン)</option>
                            </select>
                        </div>
                        <div class="grid grid-cols-2 gap-4 items-center">
                            <div>
                                <label for="textFontSize" class="block text-sm font-medium text-gray-700"><span data-lang="textFontSize">フォントサイズ</span>: <span id="textFontSize-value">48</span>px</label>
                                <input type="range" id="textFontSize" min="10" max="150" value="48" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-1">
                            </div>
                            <div>
                                <label for="textColor" class="block text-sm font-medium text-gray-700 sr-only" data-lang="textColor">テキストの色</label>
                                <input type="color" id="textColor" value="#000000" class="w-full h-10 p-1 border border-gray-300 rounded-lg cursor-pointer mt-1">
                            </div>
                        </div>
                        <div class="flex items-center justify-around">
                            <label class="checkbox-label">
                                <input type="checkbox" id="textFontBold" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                <span class="ml-2 text-sm font-medium text-gray-700" data-lang="textFontBold">太字</span>
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" id="textFontItalic" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                <span class="ml-2 text-sm font-medium text-gray-700" data-lang="textFontItalic">斜体</span>
                            </label>
                             <label class="checkbox-label">
                                <input type="checkbox" id="textHasShadow" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                <span class="ml-2 text-sm font-medium text-gray-700" data-lang="textHasShadow">影</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

        </div>

    </aside>

    <!-- メインコンテンツ -->
    <main class="main-content p-4 md:p-8">
        <header class="bg-white p-4 rounded-lg shadow-sm mb-6 flex flex-wrap items-center justify-between gap-4">
            <h1 id="app-title" class="text-xl md:text-2xl font-bold text-gray-800" data-lang="appTitle">画像放り込みレーダーチャートメーカー</h1>
            <div class="flex items-center gap-2 flex-wrap">
                <button id="export-btn" class="menu-btn font-bold py-2 px-4 rounded-lg transition-colors"><i class="fas fa-image mr-2"></i><span data-lang="export">画像出力</span></button>
                <button id="help-btn" class="menu-btn font-bold py-2 px-4 rounded-lg transition-colors"><i class="fas fa-question-circle mr-2"></i><span data-lang="help">操作方法</span></button>
                
                <div class="border-l border-gray-300 h-6 mx-2"></div>

                <button id="save-btn" class="menu-btn font-bold py-2 px-4 rounded-lg transition-colors"><i class="fas fa-save mr-2"></i><span data-lang="save">保存</span></button>
                <button id="load-btn" class="menu-btn font-bold py-2 px-4 rounded-lg transition-colors"><i class="fas fa-folder-open mr-2"></i><span data-lang="load">呼び出し</span></button>
                <input type="file" id="load-input" class="hidden" accept=".json">

                <div class="border-l border-gray-300 h-6 mx-2"></div>

                <button id="language-toggle-btn" class="menu-btn font-bold py-2 px-4 rounded-lg transition-colors"></button>
            </div>
        </header>
        <div id="canvas-container">
            <canvas id="radarCanvas"></canvas>
        </div>
    </main>
</div>

<!-- モーダルコンテナ -->
<div id="modal-container"></div>

<script>
window.onload = () => {
    // --- DOM要素 ---
    const getEl = (id) => document.getElementById(id);
    const canvas = getEl('radarCanvas');
    const ctx = canvas.getContext('2d');
    const canvasContainer = getEl('canvas-container');
    const panelTitle = getEl('panel-title');
    const backToSettingsBtn = getEl('back-to-settings-btn');
    const settingsView = getEl('settings-view');
    const helpView = getEl('help-view');
    const editView = getEl('edit-view');
    const helpBtn = getEl('help-btn');

    // --- 翻訳データ ---
    const translations = {
        ja: {
            appTitle: "画像放り込みレーダーチャートメーカー",
            settings: "設定", save: "保存", load: "呼び出し", export: "画像出力", help: "操作方法",
            settingsTitle: "チャート設定",
            fieldSettingsTitle: "フィールド設定",
            chartSettingsTitle: "チャート設定",
            labelAspectRatio: "フィールドサイズ",
            aspectRatioSquare: "正方形",
            aspectRatioLandscape: "横長",
            labelLabelFontSize: "項目文字サイズ",
            labelColor: "項目文字の色",
            labelSides: "ステータス項目の数", sidesUnit: "角形",
            labelMaxValue: "ステータスの最大値",
            labelChartLineWidth: "チャート線の太さ",
            labelChartLineColor: "チャート線の色",
            labelFillColor: "チャートの塗りつぶしの色",
            labelFillOpacity: "塗りつぶしの透過度",
            labelGridLineWidth: "枠線の太さ",
            labelGridLineColor: "枠線の色",
            btnResetFieldSettings: "フィールド設定をリセット",
            btnResetChartSettings: "チャート設定をリセット",
            exportTitle: "画像として出力",
            labelFileName: "ファイル名",
            labelExportFormat: "拡張子",
            labelExportSize: "画像サイズ",
            btnExport: "出力",
            helpTitle: "操作方法",
            editTitle: "画像/テキスト編集",
            back_to_settings: "戻る",
            labelEditMode: "編集モード",
            optionImage: "画像", optionText: "テキスト",
            labelImageClip: "画像表示方法",
            clipData: "チャート形状にクリップ", clipFrame: "グラフの枠にクリップ", clipFull: "全体表示",
            labelScale: "拡大縮小",
            labelOpacity: "透過度", 
            labelPosition: "位置（横/縦）",
            labelOffsetX: "横", 
            labelOffsetY: "縦",
            confirmTitle: "確認",
            btnNo: "いいえ", btnYes: "はい",
            confirmMessage: "画像を置き換えますか？",
            confirmReset: "このセクションの設定を初期値に戻します。よろしいですか？",
            invalidFile: "無効なファイル形式です。",
            savePlaceholder: "チャートデータ",
            exportPlaceholder: "レーダーチャート",
            lang_toggle_en: "English",
            lang_toggle_ja: "日本語",
            textContent: "テキスト内容",
            textFontFamily: "フォント",
            textFontSize: "フォントサイズ",
            textColor: "テキストの色",
            textFontBold: "太字",
            textFontItalic: "斜体",
            textHasShadow: "影",
        },
        en: {
            appTitle: "Image Drop Radar Chart Maker",
            settings: "Settings", save: "Save", load: "Load", export: "Export", help: "Help",
            settingsTitle: "Chart Settings",
            fieldSettingsTitle: "Field Settings",
            chartSettingsTitle: "Chart Settings",
            labelAspectRatio: "Field Size",
            aspectRatioSquare: "Square",
            aspectRatioLandscape: "Landscape",
            labelLabelFontSize: "Label Font Size",
            labelColor: "Label Color",
            labelSides: "Number of Status Items", sidesUnit: "",
            labelMaxValue: "Status Max Value",
            labelChartLineWidth: "Chart Line Width",
            labelChartLineColor: "Chart Line Color",
            labelFillColor: "Chart Fill Color",
            labelFillOpacity: "Fill Opacity",
            labelGridLineWidth: "Grid Line Width",
            labelGridLineColor: "Grid Line Color",
            btnResetFieldSettings: "Reset Field Settings",
            btnResetChartSettings: "Reset Chart Settings",
            exportTitle: "Export as Image",
            labelFileName: "File Name",
            labelExportFormat: "Format",
            labelExportSize: "Image Size",
            btnExport: "Export",
            helpTitle: "How to Use",
            editTitle: "Edit Image/Text",
            back_to_settings: "Back",
            labelEditMode: "Edit Mode",
            optionImage: "Image", optionText: "Text",
            labelImageClip: "Image Display Method",
            clipData: "Clip to data shape", clipFrame: "Clip to chart frame", clipFull: "Show full image",
            labelScale: "Scale",
            labelOpacity: "Opacity", 
            labelPosition: "Position (H/V)",
            labelOffsetX: "Horizontal", 
            labelOffsetY: "Vertical",
            confirmTitle: "Confirm",
            btnNo: "No", btnYes: "Yes",
            confirmMessage: "Do you want to replace the image?",
            confirmReset: "Are you sure you want to reset the settings in this section?",
            invalidFile: "Invalid file format.",
            savePlaceholder: "ChartData",
            exportPlaceholder: "RadarChart",
            lang_toggle_en: "English",
            lang_toggle_ja: "日本語",
            textContent: "Text Content",
            textFontFamily: "Font",
            textFontSize: "Font Size",
            textColor: "Text Color",
            textFontBold: "Bold",
            textFontItalic: "Italic",
            textHasShadow: "Shadow",
        }
    };

    function getHelpContent(lang) {
        return lang === 'ja' ? `
            <h3 class="font-semibold mb-2">画像の設定</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>画像の読込:</strong> PCから右側のチャートエリアに画像をドラッグ＆ドロップします。</li>
                <li><strong>画像の変更:</strong> 新しい画像をドラッグ＆ドロップすると変更できます。</li>
            </ul>
            <h3 class="font-semibold mt-4 mb-2">チャートの編集</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>数値の変更:</strong> チャート上の黒い点をドラッグします。</li>
                <li><strong>項目名の変更:</strong> "A", "B"などの項目名をダブルクリックします。</li>
                <li><strong>画像/テキストの調整:</strong> チャートエリア内をダブルクリックすると左パネルが編集モードに切り替わります。</li>
            </ul>
            <h3 class="font-semibold mt-4 mb-2">設定のカスタマイズ</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>各種設定:</strong> 左側の「チャート設定」パネルで、チャートの形、色、線の太さなどを変更できます。設定は自動で保存されます。</li>
            </ul>
        ` : `
            <h3 class="font-semibold mb-2">Image Settings</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>Load Image:</strong> Drag & drop an image from your PC to the chart area on the right.</li>
                <li><strong>Change Image:</strong> You can change the image by dragging & dropping a new one.</li>
            </ul>
            <h3 class="font-semibold mt-4 mb-2">Chart Editing</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>Change Values:</strong> Drag the black dots on the chart.</li>
                <li><strong>Change Labels:</strong> Double-click on labels like "A", "B".</li>
                <li><strong>Adjust Image/Text:</strong> Double-click inside the chart area to switch the left panel to edit mode.</li>
            </ul>
            <h3 class="font-semibold mt-4 mb-2">Customization</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>Various Settings:</strong> Change the chart's shape, colors, line widths, etc., in the 'Chart Settings' panel. Settings are saved automatically.</li>
            </ul>
        `;
    }

    // --- 状態管理 ---
    let state = {};
    let chartGeometry = {};
    
    function getDefaultTextSettings() {
        return {
            value: '',
            fontSize: 48,
            fontFamily: "Inter, 'Noto Sans JP', sans-serif",
            color: '#000000',
            isBold: false,
            isItalic: false,
            hasShadow: false,
        };
    }

    function getDefaultSettings() {
        return {
            language: 'ja',
            aspectRatio: 'landscape',
            sides: 5, 
            maxValue: 5, 
            gridLineWidth: 1, 
            gridLineColor: '#cccccc', 
            labelFontSize: 20, 
            labelColor: '#333333',
            chartLineWidth: 2, 
            chartLineColor: '#000000',
            fillColor: '#000000',
            fillOpacity: 0.3, 
            imageClip: 'data',
        };
    }

    function resetState() {
        state = {
            settings: getDefaultSettings(),
            chartData: {
                labels: ['A', 'B', 'C', 'D', 'E'],
                values: [1, 1, 1, 1, 1],
            },
            image: {
                element: null, name: '', opacity: 1.0, offsetX: 0, offsetY: 0, scale: 1.0,
            },
            text: getDefaultTextSettings(),
            editMode: 'image',
            draggingPoint: -1,
            editingLabel: -1,
        }
    }

    // --- 初期化 ---
    function init() {
        resetState();
        loadSettings();
        setupEventListeners();
        showPanelView('settings');
        updateLanguage();
        resizeCanvas();
        updateChartData(state.settings.sides);
        updateAndSaveSettings();
        draw();
    }

    // --- パネルビュー管理 ---
    function showPanelView(view) {
        settingsView.classList.add('hidden');
        helpView.classList.add('hidden');
        editView.classList.add('hidden');
        backToSettingsBtn.classList.add('hidden');
        
        document.querySelectorAll('.menu-btn.active-help').forEach(b => b.classList.remove('active-help'));

        if (view === 'settings') {
            panelTitle.textContent = t('settingsTitle');
            settingsView.classList.remove('hidden');
        } else if (view === 'help') {
            panelTitle.textContent = t('helpTitle');
            helpView.innerHTML = getHelpContent(state.settings.language);
            helpView.classList.remove('hidden');
            backToSettingsBtn.classList.remove('hidden');
            helpBtn.classList.add('active-help');
        } else if (view === 'edit') {
            panelTitle.textContent = t('editTitle');
            editView.classList.remove('hidden');
            backToSettingsBtn.classList.remove('hidden');
            updateEditViewUI();
        }
    }

    // --- 言語設定 ---
    function t(key) { return translations[state.settings.language][key] || key; }
    function updateLanguage() {
        const lang = state.settings.language;
        document.documentElement.lang = lang;
        document.querySelectorAll('[data-lang]').forEach(el => {
            const key = el.dataset.lang;
            if (translations[lang] && translations[lang][key]) {
                const icon = el.querySelector('i');
                if (icon) {
                    el.innerHTML = `<i class="${icon.className}"></i> ${translations[lang][key]}`;
                } else {
                    el.innerHTML = translations[lang][key];
                }
            }
        });
        getEl('language-toggle-btn').textContent = lang === 'ja' ? t('lang_toggle_en') : t('lang_toggle_ja');
        const sidesUnitEl = document.querySelector('span[data-lang="sidesUnit"]');
        if (sidesUnitEl) {
            sidesUnitEl.textContent = lang === 'ja' ? `角形` : '';
        }
        if (!settingsView.classList.contains('hidden')) showPanelView('settings');
        else if (!helpView.classList.contains('hidden')) showPanelView('help');
        else if (!editView.classList.contains('hidden')) showPanelView('edit');
    }

    // --- キャンバスのリサイズ ---
    function resizeCanvas() {
        const rect = canvasContainer.getBoundingClientRect();
        
        if (state.settings.aspectRatio === 'square') {
            const size = Math.min(rect.width, rect.height);
            canvas.width = size;
            canvas.height = size;
        } else { // landscape
            const containerW = rect.width;
            const containerH = rect.height;
            const targetRatio = 1.2;

            if (containerW / containerH > targetRatio) {
                canvas.height = containerH;
                canvas.width = containerH * targetRatio;
            } else {
                canvas.width = containerW;
                canvas.height = containerW / targetRatio;
            }
        }
        draw();
    }
    window.addEventListener('resize', resizeCanvas);

    // --- 設定の更新と保存 ---
    function updateAndSaveSettings() {
        state.settings.aspectRatio = document.querySelector('input[name="aspectRatio"]:checked').value;
        state.settings.sides = parseInt(getEl('sides').value);
        state.settings.maxValue = parseInt(getEl('maxValue').value);
        state.settings.chartLineWidth = parseInt(getEl('chartLineWidth').value);
        state.settings.chartLineColor = getEl('chartLineColor').value;
        state.settings.gridLineWidth = parseInt(getEl('gridLineWidth').value);
        state.settings.gridLineColor = getEl('gridLineColor').value;
        state.settings.fillColor = getEl('fillColor').value;
        state.settings.fillOpacity = parseInt(getEl('fillOpacity').value) / 100;
        state.settings.labelFontSize = parseInt(getEl('labelFontSize').value);
        state.settings.labelColor = getEl('labelColor').value;
        state.settings.imageClip = getEl('imageClip').value;
        
        getEl('sides-value').textContent = state.settings.sides;
        getEl('maxValue-value').textContent = state.settings.maxValue;
        getEl('chartLineWidth-value').textContent = state.settings.chartLineWidth;
        getEl('gridLineWidth-value').textContent = state.settings.gridLineWidth;
        getEl('fillOpacity-value').textContent = Math.round(state.settings.fillOpacity * 100);
        getEl('labelFontSize-value').textContent = state.settings.labelFontSize;
        
        if (state.chartData.labels.length !== state.settings.sides) {
            updateChartData(state.settings.sides);
        }

        saveSettings();
        resizeCanvas();
    }

    function saveSettings() {
        localStorage.setItem('radarChartSettingsUnified', JSON.stringify(state.settings));
    }

    function loadSettings() {
        const savedSettings = localStorage.getItem('radarChartSettingsUnified');
        const defaultSettings = getDefaultSettings();
        if (savedSettings) {
            state.settings = { ...defaultSettings, ...JSON.parse(savedSettings) };
        } else {
            state.settings = defaultSettings;
        }
        updateSettingsUI();
    }

    function updateSettingsUI() {
        document.querySelector(`input[name="aspectRatio"][value="${state.settings.aspectRatio}"]`).checked = true;
        Object.keys(state.settings).forEach(key => {
            const el = getEl(key);
            if(el) {
                if (key === 'fillOpacity') {
                    el.value = state.settings[key] * 100;
                } else {
                    el.value = state.settings[key];
                }
            }
        });
    }

    // --- チャートデータの更新 ---
    function updateChartData(newSides) {
        const defaultLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
        const currentLength = state.chartData.labels.length;

        if (newSides > currentLength) {
            for (let i = currentLength; i < newSides; i++) {
                state.chartData.labels.push(defaultLabels[i % defaultLabels.length]);
                state.chartData.values.push(1);
            }
        } else if (newSides < currentLength) {
            state.chartData.labels.splice(newSides);
            state.chartData.values.splice(newSides);
        }
    }
    
    function drawOnContext(targetCtx, width, height, geometry) {
        targetCtx.clearRect(0, 0, width, height);

        const { cx, cy, r, textCenterX, textCenterY, maxTextWidth } = geometry;

        if (state.editMode === 'image' && state.image.element) {
            drawImage(targetCtx, cx, cy, r);
        } else if (state.editMode === 'text' && state.text.value) {
            drawText(targetCtx, textCenterX, textCenterY, maxTextWidth);
        }
        
        drawGrid(targetCtx, cx, cy, r);
        drawChart(targetCtx, cx, cy, r);
        drawLabels(targetCtx, cx, cy, r);
        drawPoints(targetCtx, cx, cy, r);
    }

    // --- 描画処理 ---
    function draw() {
        const width = canvas.width;
        const height = canvas.height;
        const geometry = calculateGeometry(width, height);
        chartGeometry = geometry; // Update global geometry for interaction handlers
        drawOnContext(ctx, width, height, geometry);
    }

    function calculateGeometry(width, height) {
        const cx = width / 2;
        const cy = height / 2;
        let r = Math.min(width, height) / 2 * 0.75;

        if (state.settings.aspectRatio === 'landscape' && width / height > 1.1) {
            const chartAreaSize = height;
             return {
                cx: cx, // Center in the full canvas width
                cy: cy,
                r: (chartAreaSize / 2) * 0.75,
                textCenterX: cx,
                textCenterY: cy,
                maxTextWidth: r * 1.8,
            };
        } else {
            return {
                cx: cx,
                cy: cy,
                r: r,
                textCenterX: cx,
                textCenterY: cy,
                maxTextWidth: r * 1.8,
            };
        }
    }
    
    function drawImage(targetCtx, cx, cy, r) {
        targetCtx.save();
        if (state.settings.imageClip === 'frame' || state.settings.imageClip === 'data') {
            targetCtx.beginPath();
            for (let i = 0; i < state.settings.sides; i++) {
                let clipRadius = (state.settings.imageClip === 'frame') ? r : (r / state.settings.maxValue) * state.chartData.values[i];
                const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
                const x = cx + clipRadius * Math.cos(angle);
                const y = cy + clipRadius * Math.sin(angle);
                if (i === 0) targetCtx.moveTo(x, y);
                else targetCtx.lineTo(x, y);
            }
            targetCtx.closePath();
            targetCtx.clip();
        }

        const img = state.image.element;
        const polyWidth = r * 2;
        const polyHeight = r * 2;
        let drawWidth, drawHeight;
        const imgAspectRatio = img.width / img.height;
        
        if (imgAspectRatio > 1) {
            drawHeight = polyHeight;
            drawWidth = drawHeight * imgAspectRatio;
        } else {
            drawWidth = polyWidth;
            drawHeight = drawWidth / imgAspectRatio;
        }
        
        drawWidth *= state.image.scale;
        drawHeight *= state.image.scale;

        const dx = cx - drawWidth / 2 + state.image.offsetX;
        const dy = cy - drawHeight / 2 + state.image.offsetY;

        targetCtx.globalAlpha = state.image.opacity;
        targetCtx.drawImage(img, dx, dy, drawWidth, drawHeight);
        targetCtx.restore();
    }

    function drawText(targetCtx, cx, cy, maxTextWidth) {
        targetCtx.save();
        const txt = state.text;
        targetCtx.textAlign = 'center';
        targetCtx.textBaseline = 'middle';
        targetCtx.fillStyle = txt.color;
        
        const fontStyle = txt.isItalic ? 'italic' : 'normal';
        const fontWeight = txt.isBold ? 'bold' : 'normal';
        targetCtx.font = `${fontStyle} ${fontWeight} ${txt.fontSize}px "${txt.fontFamily.split(',')[0]}"`;

        if (txt.hasShadow) {
            targetCtx.shadowColor = 'rgba(0,0,0,0.5)';
            targetCtx.shadowBlur = 5;
            targetCtx.shadowOffsetX = 2;
            targetCtx.shadowOffsetY = 2;
        }

        const textToDraw = txt.value;
        const textWidth = targetCtx.measureText(textToDraw).width;
        
        if(textWidth > maxTextWidth){
            const scale = maxTextWidth / textWidth;
            targetCtx.font = `${fontStyle} ${fontWeight} ${txt.fontSize * scale}px "${txt.fontFamily.split(',')[0]}"`;
        }

        targetCtx.fillText(textToDraw, cx, cy);
        targetCtx.restore();
    }

    function drawGrid(targetCtx, cx, cy, r) {
        if (state.settings.gridLineWidth <= 0) return;
        targetCtx.strokeStyle = state.settings.gridLineColor;
        targetCtx.lineWidth = state.settings.gridLineWidth;
        for (let j = 1; j <= state.settings.maxValue; j++) {
            const currentRadius = (r / state.settings.maxValue) * j;
            targetCtx.beginPath();
            for (let i = 0; i < state.settings.sides; i++) {
                const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
                const x = cx + currentRadius * Math.cos(angle);
                const y = cy + currentRadius * Math.sin(angle);
                if (i === 0) targetCtx.moveTo(x, y);
                else targetCtx.lineTo(x, y);
            }
            targetCtx.closePath();
            targetCtx.stroke();
        }
        for (let i = 0; i < state.settings.sides; i++) {
            const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
            targetCtx.beginPath();
            targetCtx.moveTo(cx, cy);
            targetCtx.lineTo(cx + r * Math.cos(angle), cy + r * Math.sin(angle));
            targetCtx.stroke();
        }
    }

    function drawChart(targetCtx, cx, cy, r) {
        targetCtx.strokeStyle = state.settings.chartLineColor;
        targetCtx.fillStyle = hexToRgba(state.settings.fillColor, state.settings.fillOpacity);
        targetCtx.lineWidth = state.settings.chartLineWidth;
        targetCtx.beginPath();
        for (let i = 0; i < state.settings.sides; i++) {
            const value = state.chartData.values[i];
            const currentRadius = (r / state.settings.maxValue) * value;
            const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
            const x = cx + currentRadius * Math.cos(angle);
            const y = cy + currentRadius * Math.sin(angle);
            if (i === 0) targetCtx.moveTo(x, y);
            else targetCtx.lineTo(x, y);
        }
        targetCtx.closePath();
        targetCtx.stroke();
        targetCtx.fill();
    }

    function drawLabels(targetCtx, cx, cy, r) {
        targetCtx.fillStyle = state.settings.labelColor;
        targetCtx.textAlign = 'center';
        targetCtx.textBaseline = 'middle';
        
        const labelRadius = r * 1.15;
        for (let i = 0; i < state.settings.sides; i++) {
            const label = state.chartData.labels[i];
            const value = state.chartData.values[i];
            const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
            
            let x = cx + labelRadius * Math.cos(angle);
            let y = cy + labelRadius * Math.sin(angle);

            if (i === 0) { // Top label
                y -= state.settings.labelFontSize * 0.5;
            }

            targetCtx.font = `${state.settings.labelFontSize}px sans-serif`;
            targetCtx.fillText(label, x, y);
            
            targetCtx.font = `${state.settings.labelFontSize * 0.8}px sans-serif`;
            targetCtx.fillText(`(${value})`, x, y + state.settings.labelFontSize * 1.1);
        }
    }

    function drawPoints(targetCtx, cx, cy, r) {
        for (let i = 0; i < state.settings.sides; i++) {
            const value = state.chartData.values[i];
            const currentRadius = (r / state.settings.maxValue) * value;
            const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
            const x = cx + currentRadius * Math.cos(angle);
            const y = cy + currentRadius * Math.sin(angle);
            targetCtx.beginPath();
            targetCtx.arc(x, y, 5, 0, 2 * Math.PI);
            targetCtx.fillStyle = state.settings.chartLineColor;
            targetCtx.fill();
        }
    }
    
    // --- イベントリスナー設定 ---
    function setupEventListeners() {
        // Header buttons
        helpBtn.addEventListener('click', () => showPanelView('help'));
        getEl('save-btn').addEventListener('click', saveChartData);
        getEl('load-btn').addEventListener('click', () => getEl('load-input').click());
        getEl('load-input').addEventListener('change', loadChartData);
        getEl('export-btn').addEventListener('click', showExportModal);
        getEl('language-toggle-btn').addEventListener('click', () => {
            state.settings.language = state.settings.language === 'ja' ? 'en' : 'ja';
            updateLanguage();
            saveSettings();
        });
        
        // Panel controls
        backToSettingsBtn.addEventListener('click', () => showPanelView('settings'));

        // Accordion
        ['field-settings', 'chart-settings'].forEach(id => {
            const toggle = getEl(`${id}-toggle`);
            const content = getEl(`${id}-content`);
            const icon = toggle.querySelector('i');
            toggle.addEventListener('click', () => {
                content.classList.toggle('hidden');
                icon.classList.toggle('fa-chevron-up');
                icon.classList.toggle('fa-chevron-down');
            });
        });

        // Settings view inputs
        const settingsInputs = [
            'sides', 'maxValue', 'chartLineWidth', 'chartLineColor', 'gridLineWidth', 
            'gridLineColor', 'fillColor', 'fillOpacity', 'labelFontSize', 'labelColor'
        ];
        settingsInputs.forEach(id => getEl(id).addEventListener('input', updateAndSaveSettings));
        document.querySelectorAll('input[name="aspectRatio"]').forEach(radio => {
            radio.addEventListener('change', updateAndSaveSettings);
        });
        getEl('reset-field-settings-btn').addEventListener('click', () => {
            showConfirmDialog(t('confirmReset'), () => {
                const defaults = getDefaultSettings();
                const fieldKeys = ['aspectRatio', 'sides', 'maxValue', 'gridLineWidth', 'gridLineColor', 'labelFontSize', 'labelColor'];
                fieldKeys.forEach(key => state.settings[key] = defaults[key]);
                updateSettingsUI();
                updateAndSaveSettings();
            });
        });
        getEl('reset-chart-settings-btn').addEventListener('click', () => {
             showConfirmDialog(t('confirmReset'), () => {
                const defaults = getDefaultSettings();
                const chartKeys = ['chartLineWidth', 'chartLineColor', 'fillColor', 'fillOpacity'];
                chartKeys.forEach(key => state.settings[key] = defaults[key]);
                updateSettingsUI();
                updateAndSaveSettings();
            });
        });

        // Edit view inputs
        getEl('imageClip').addEventListener('change', updateAndSaveSettings);
        getEl('imageScale').addEventListener('input', updateImageSettings);
        getEl('imageOpacity').addEventListener('input', updateImageSettings);
        getEl('imageOffsetX').addEventListener('input', updateImageSettings);
        getEl('imageOffsetY').addEventListener('input', updateImageSettings);
        getEl('editMode').addEventListener('change', (e) => { state.editMode = e.target.value; toggleEditControls(); draw(); });
        
        // Text controls
        const textControls = ['textValue', 'textFontFamily', 'textFontSize', 'textColor', 'textFontBold', 'textFontItalic', 'textHasShadow'];
        textControls.forEach(id => {
            const el = getEl(id);
            const eventType = el.type === 'checkbox' ? 'change' : 'input';
            el.addEventListener(eventType, () => {
                state.text.value = getEl('textValue').value;
                state.text.fontFamily = getEl('textFontFamily').value;
                state.text.fontSize = parseInt(getEl('textFontSize').value);
                state.text.color = getEl('textColor').value;
                state.text.isBold = getEl('textFontBold').checked;
                state.text.isItalic = getEl('textFontItalic').checked;
                state.text.hasShadow = getEl('textHasShadow').checked;
                getEl('textFontSize-value').textContent = state.text.fontSize;
                draw();
            });
        });

        // Drag & Drop
        canvasContainer.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); canvasContainer.classList.add('drag-over'); });
        canvasContainer.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); canvasContainer.classList.remove('drag-over'); });
        canvasContainer.addEventListener('drop', handleImageDrop);

        // Canvas interaction
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('dblclick', handleDoubleClick);
    }
    
    // --- 画像処理 ---
    function handleImageDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        canvasContainer.classList.remove('drag-over');
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('image/')) {
            if (state.image.element) {
                showConfirmDialog(t('confirmMessage'), () => loadImage(file));
            } else {
                loadImage(file);
            }
        }
    }

    function loadImage(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                state.image.element = img;
                state.image.name = file.name.split('.').slice(0, -1).join('.');
                state.image.scale = 1.0;
                state.settings.imageClip = 'frame';
                saveSettings();
                state.editMode = 'image';
                draw();
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    // --- キャンバスインタラクション ---
    function getMousePos(e) { const rect = canvas.getBoundingClientRect(); return { x: e.clientX - rect.left, y: e.clientY - rect.top }; }

    function handleMouseDown(e) {
        const pos = getMousePos(e);
        const { cx, cy, r } = chartGeometry;
        for (let i = 0; i < state.settings.sides; i++) {
            const value = state.chartData.values[i];
            const currentRadius = (r / state.settings.maxValue) * value;
            const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
            const pointX = cx + currentRadius * Math.cos(angle);
            const pointY = cy + currentRadius * Math.sin(angle);
            const distance = Math.sqrt(Math.pow(pos.x - pointX, 2) + Math.pow(pos.y - pointY, 2));
            if (distance < 10) { state.draggingPoint = i; canvas.style.cursor = 'grabbing'; return; }
        }
    }

    function handleMouseMove(e) {
        const pos = getMousePos(e);
        const { cx, cy, r } = chartGeometry;
        if (state.draggingPoint === -1) {
            let onPoint = false;
            for (let i = 0; i < state.settings.sides; i++) {
                const value = state.chartData.values[i];
                const currentRadius = (r / state.settings.maxValue) * value;
                const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
                const pointX = cx + currentRadius * Math.cos(angle);
                const pointY = cy + currentRadius * Math.sin(angle);
                const distance = Math.sqrt(Math.pow(pos.x - pointX, 2) + Math.pow(pos.y - pointY, 2));
                if (distance < 10) { onPoint = true; break; }
            }
            canvas.style.cursor = onPoint ? 'grab' : 'crosshair';
            return;
        }
        
        const dx = pos.x - cx;
        const dy = pos.y - cy;
        const targetAngle = (state.draggingPoint / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
        const distanceOnAxis = (dx * Math.cos(targetAngle) + dy * Math.sin(targetAngle));
        let value = (distanceOnAxis / r) * state.settings.maxValue;
        value = Math.max(0, Math.min(state.settings.maxValue, Math.round(value)));
        state.chartData.values[state.draggingPoint] = value;
        draw();
    }

    function handleMouseUp() { state.draggingPoint = -1; canvas.style.cursor = 'crosshair'; }

    function handleDoubleClick(e) {
        const pos = getMousePos(e);
        const { cx, cy, r } = chartGeometry;
        for (let i = 0; i < state.settings.sides; i++) {
            const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
            const labelRadius = r * 1.15;
            const labelX = cx + labelRadius * Math.cos(angle);
            const labelY = cy + labelRadius * Math.sin(angle);
            ctx.font = `${state.settings.labelFontSize}px sans-serif`;
            const textMetrics = ctx.measureText(state.chartData.labels[i]);
            const textWidth = textMetrics.width;
            const textHeight = state.settings.labelFontSize;
            if (pos.x > labelX - textWidth / 2 && pos.x < labelX + textWidth / 2 && pos.y > labelY - textHeight / 2 && pos.y < labelY + textHeight / 2) {
                createLabelInput(i, labelX, labelY);
                return;
            }
        }
        const distance = Math.sqrt(Math.pow(pos.x - cx, 2) + Math.pow(pos.y - cy, 2));
        if (distance < r) { showPanelView('edit'); }
    }
    
    function createLabelInput(index, x, y) {
        if(state.editingLabel !== -1) return;
        state.editingLabel = index;
        const originalValue = state.chartData.labels[index];
        const input = document.createElement('input');
        input.type = 'text';
        input.value = originalValue;
        input.className = 'label-input w-24 text-center border border-indigo-500 rounded-md';
        input.style.left = `${x}px`;
        input.style.top = `${y}px`;
        input.style.fontSize = `${state.settings.labelFontSize}px`;
        input.addEventListener('blur', () => {
            const newValue = input.value.trim();
            state.chartData.labels[index] = newValue === '' ? originalValue : newValue;
            canvasContainer.removeChild(input);
            state.editingLabel = -1;
            draw();
        });
        input.addEventListener('keydown', (e) => { if (e.key === 'Enter') { input.blur(); } });
        canvasContainer.appendChild(input);
        input.focus();
        input.select();
    }

    // --- 編集ビュー制御 ---
    function updateEditViewUI() {
        getEl('editMode').value = state.editMode;
        // Image controls
        getEl('imageClip').value = state.settings.imageClip;
        getEl('imageScale').value = state.image.scale * 100;
        getEl('imageScale-value').textContent = Math.round(state.image.scale * 100);
        getEl('imageOpacity').value = state.image.opacity * 100;
        getEl('imageOpacity-value').textContent = Math.round(state.image.opacity * 100);
        getEl('imageOffsetX').value = state.image.offsetX;
        getEl('imageOffsetX-value').textContent = state.image.offsetX;
        getEl('imageOffsetY').value = state.image.offsetY;
        getEl('imageOffsetY-value').textContent = state.image.offsetY;
        // Text controls
        const txt = state.text;
        getEl('textValue').value = txt.value;
        getEl('textFontFamily').value = txt.fontFamily;
        getEl('textFontSize').value = txt.fontSize;
        getEl('textFontSize-value').textContent = txt.fontSize;
        getEl('textColor').value = txt.color;
        getEl('textFontBold').checked = txt.isBold;
        getEl('textFontItalic').checked = txt.isItalic;
        getEl('textHasShadow').checked = txt.hasShadow;

        toggleEditControls();
    }

    function toggleEditControls() {
        if (state.editMode === 'image') {
            getEl('image-controls').classList.remove('hidden');
            getEl('text-controls').classList.add('hidden');
        } else {
            getEl('image-controls').classList.add('hidden');
            getEl('text-controls').classList.remove('hidden');
        }
    }

    function updateImageSettings() {
        state.image.opacity = parseInt(getEl('imageOpacity').value) / 100;
        state.image.offsetX = parseInt(getEl('imageOffsetX').value);
        state.image.offsetY = parseInt(getEl('imageOffsetY').value);
        state.image.scale = parseInt(getEl('imageScale').value) / 100;
        getEl('imageOpacity-value').textContent = Math.round(state.image.opacity * 100);
        getEl('imageOffsetX-value').textContent = state.image.offsetX;
        getEl('imageOffsetY-value').textContent = state.image.offsetY;
        getEl('imageScale-value').textContent = Math.round(state.image.scale * 100);
        draw();
    }
    
    // --- モーダル制御 ---
    function showConfirmDialog(message, onConfirm) {
        const modalContainer = getEl('modal-container');
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.innerHTML = `
            <div class="modal-content w-full max-w-sm">
                <h3 class="text-lg font-medium">${t('confirmTitle')}</h3>
                <p class="mt-2 text-sm text-gray-600">${message}</p>
                <div class="mt-4 flex justify-end space-x-2">
                    <button id="confirmNo" class="px-4 py-2 bg-gray-200 rounded-md">${t('btnNo')}</button>
                    <button id="confirmYes" class="px-4 py-2 bg-red-600 text-white rounded-md">${t('btnYes')}</button>
                </div>
            </div>`;
        
        modal.querySelector('#confirmYes').addEventListener('click', () => {
            onConfirm();
            modalContainer.innerHTML = '';
        });
        modal.querySelector('#confirmNo').addEventListener('click', () => modalContainer.innerHTML = '');
        modal.addEventListener('click', (e) => { if(e.target === modal) modalContainer.innerHTML = ''; });
        
        modalContainer.appendChild(modal);
    }

    function showExportModal() {
        const modalContainer = getEl('modal-container');
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.innerHTML = `
            <div class="modal-content">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold">${t('exportTitle')}</h2>
                    <button class="close-modal-btn text-gray-500 hover:text-gray-800 text-3xl">&times;</button>
                </div>
                <div class="space-y-4">
                    <div>
                        <label for="exportFileName" class="block text-sm font-medium text-gray-700">${t('labelFileName')}</label>
                        <input type="text" id="exportFileName" placeholder="${state.image.name || t('exportPlaceholder')}" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div>
                        <label for="exportFormat" class="block text-sm font-medium text-gray-700">${t('labelExportFormat')}</label>
                        <select id="exportFormat" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                            <option value="png">PNG</option>
                            <option value="jpeg">JPEG</option>
                            <option value="webp">WebP</option>
                        </select>
                    </div>
                    <div>
                        <label for="exportSize" class="block text-sm font-medium text-gray-700"><span data-lang="labelExportSize">${t('labelExportSize')}</span>: <span id="exportSize-value">800</span>px</label>
                        <input type="range" id="exportSize" min="400" max="2000" step="100" value="800" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <button id="download-image-btn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">${t('btnExport')}</button>
                </div>
            </div>`;
        
        modal.querySelector('.close-modal-btn').addEventListener('click', () => modalContainer.innerHTML = '');
        modal.addEventListener('click', (e) => { if (e.target === modal) modalContainer.innerHTML = ''; });
        modal.querySelector('#exportSize').addEventListener('input', (e) => { modal.querySelector('#exportSize-value').textContent = e.target.value; });
        modal.querySelector('#download-image-btn').addEventListener('click', exportImage);
        
        modalContainer.appendChild(modal);
    }

    // --- ファイル操作 ---
    function saveChartData() {
        const defaultName = state.image.name ? `${state.image.name}-Chart` : t('savePlaceholder');
        const fileName = prompt(t('labelFileName'), defaultName);
        if(!fileName) return;

        const dataToSave = {
            version: '5.0',
            settings: state.settings, chartData: state.chartData,
            image: { dataUrl: state.image.element ? state.image.element.src : null, name: state.image.name, opacity: state.image.opacity, offsetX: state.image.offsetX, offsetY: state.image.offsetY, scale: state.image.scale },
            text: state.text, editMode: state.editMode,
        };
        const dataStr = JSON.stringify(dataToSave, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${fileName}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function loadChartData(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const loadedData = JSON.parse(event.target.result);
                const defaultSettings = getDefaultSettings();
                state.settings = { ...defaultSettings, ...loadedData.settings };
                state.chartData = loadedData.chartData;
                state.text = { ...getDefaultTextSettings(), ...loadedData.text };
                state.editMode = loadedData.editMode || 'image';
                
                loadSettings();
                updateLanguage();
                updateAndSaveSettings();
                
                if (loadedData.image && loadedData.image.dataUrl) {
                    const img = new Image();
                    img.onload = () => {
                        state.image = { ...state.image, ...loadedData.image, element: img, scale: loadedData.image.scale || 1.0 };
                        draw();
                    };
                    img.src = loadedData.image.dataUrl;
                } else {
                    state.image = { element: null, name: '', opacity: 1.0, offsetX: 0, offsetY: 0, scale: 1.0 };
                    draw();
                }
            } catch (error) {
                console.error("File loading failed:", error);
                alert(t('invalidFile'));
            }
        };
        reader.readAsText(file);
        getEl('load-input').value = '';
    }

    function exportImage() {
        const fileNameInput = getEl('exportFileName');
        let fileName = fileNameInput.value.trim() || fileNameInput.placeholder;
        const format = getEl('exportFormat').value;
        const size = parseInt(getEl('exportSize').value);
        
        const tempCanvas = document.createElement('canvas');
        
        if (state.settings.aspectRatio === 'landscape') {
            tempCanvas.width = size * 1.2;
            tempCanvas.height = size;
        } else {
            tempCanvas.width = size;
            tempCanvas.height = size;
        }
        
        const tempCtx = tempCanvas.getContext('2d');
        const geometry = calculateGeometry(tempCanvas.width, tempCanvas.height);

        // Draw everything on the temporary canvas
        drawOnContext(tempCtx, tempCanvas.width, tempCanvas.height, geometry);

        const imageType = `image/${format}`;
        const dataUrl = tempCanvas.toDataURL(imageType, format === 'jpeg' ? 0.9 : 1.0);
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = `${fileName}.${format}`;
        a.click();
        
        getEl('modal-container').innerHTML = '';
    }
    
    // --- ヘルパー関数 ---
    function hexToRgba(hex, alpha) {
        let r = 0, g = 0, b = 0;
        if (hex.length == 4) { r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3]; }
        else if (hex.length == 7) { r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6]; }
        return `rgba(${+r},${+g},${+b},${alpha})`;
    }

    init();
};
</script>

</body>
</html>
