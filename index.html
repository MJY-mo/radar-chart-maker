<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>画像放り込みレーダーチャートメーカー</title>
    <link rel="icon" href="favicon3.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,wght@0,400;0,700;1,400;1,700&family=Lobster&family=Merriweather:ital,wght@0,400;0,700;1,400;1,700&family=Noto+Sans+JP:wght@400;700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
    <style>
        /* カスタムスタイル */
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background-color: #f0f2f5;
            overscroll-behavior: none;
        }
        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .left-panel {
            width: 350px;
            flex-shrink: 0;
            background-color: white;
            height: 100vh;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #e2e8f0;
        }
        .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow-y: auto;
        }
        #canvas-container {
            flex-grow: 1;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            border: 3px dashed transparent;
            transition: border-color 0.3s, background-color 0.3s;
            padding: 1.5rem; /* コンテナ内の余白を追加 */
            margin: auto;
            width: 100%;
            max-width: 810px;
            max-height: 810px;
        }
        #canvas-container.drag-over {
            border-color: #4f46e5;
            background-color: #eef2ff !important; /* Ensure override */
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
            max-width: 90%;
            width: 500px;
        }
        canvas {
            cursor: crosshair;
            background-color: transparent;
        }
        .label-input {
            position: absolute;
            transform: translate(-50%, -50%);
            z-index: 10;
        }
        #help-view ul {
            list-style-type: disc;
            padding-left: 1.5rem;
        }
        #help-view li {
            margin-bottom: 0.5rem;
        }
        #help-view strong {
            color: #4F46E5;
        }
        .menu-btn {
            background-color: #6b7280; /* gray-500 */
            color: white;
        }
        .menu-btn:hover {
            background-color: #4b5563; /* gray-600 */
        }
        .menu-btn.active-help {
            background-color: #10b981; /* green-500 */
        }
        .menu-btn.active-help:hover {
            background-color: #059669; /* green-600 */
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .accordion-content {
            transition: max-height 0.3s ease-out, visibility 0.3s, opacity 0.3s;
            overflow: hidden;
            max-height: 0;
            visibility: hidden;
            opacity: 0;
        }
        .accordion-content.open {
            max-height: 2000px; /* 十分な高さを確保 */
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>

<div class="app-container">
    <!-- 左側設定パネル -->
    <aside class="left-panel">
        <div class="p-6 border-b">
            <div id="panel-header" class="flex justify-between items-center">
                <h2 id="panel-title" class="text-2xl font-bold"></h2>
                <button id="back-to-settings-btn" class="hidden bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg transition-colors"><i class="fas fa-arrow-left mr-2"></i><span data-lang="back_to_settings">戻る</span></button>
            </div>
        </div>

        <div class="panel-content">
            <!-- 設定ビュー -->
            <div id="settings-view" class="space-y-4">
                <!-- フィールド設定 -->
                <div>
                    <button data-accordion-toggle="field-settings-content" class="w-full flex justify-between items-center p-3 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors">
                        <span class="font-semibold" data-lang="fieldSettingsTitle">フィールド設定</span>
                        <i class="fas fa-chevron-down transition-transform"></i>
                    </button>
                    <div id="field-settings-content" class="accordion-content mt-4 space-y-6 pl-4 border-l-2 border-gray-200">
                        <div>
                            <label class="block text-sm font-medium text-gray-700" data-lang="labelGraphSize">グラフサイズ</label>
                            <div class="mt-2 flex space-x-4">
                                <label class="inline-flex items-center">
                                    <input type="radio" name="graphSize" value="large" class="form-radio">
                                    <span class="ml-2 text-sm" data-lang="graphSizeLarge">大</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="graphSize" value="medium">
                                    <span class="ml-2 text-sm" data-lang="graphSizeMedium">中</span>
                                </label>
                                <label class="inline-flex items-center">
                                    <input type="radio" name="graphSize" value="small">
                                    <span class="ml-2 text-sm" data-lang="graphSizeSmall">小</span>
                                </label>
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4 items-center">
                             <div>
                                <label for="backgroundColorOpacity" class="block text-sm font-medium text-gray-700"><span data-lang="labelBackgroundColorOpacity">背景の透過度</span>: <span id="backgroundColorOpacity-value">100</span>%</label>
                                <input type="range" id="backgroundColorOpacity" min="0" max="100" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <div>
                                <label for="backgroundColor" class="block text-sm font-medium text-gray-700 sr-only" data-lang="labelBackgroundColor">背景色</label>
                                <input type="color" id="backgroundColor" value="#FFFFFF" class="w-full h-10 p-1 border border-gray-300 rounded-lg cursor-pointer">
                            </div>
                        </div>
                        <div>
                            <label for="maxValue" class="block text-sm font-medium text-gray-700"><span data-lang="labelMaxValue">ステータスの最大値</span>: <span id="maxValue-value">5</span></label>
                            <input type="range" id="maxValue" min="4" max="10" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div class="grid grid-cols-2 gap-4 items-center">
                            <div>
                                <label for="gridLineWidth" class="block text-sm font-medium text-gray-700"><span data-lang="labelGridLineWidth">枠線の太さ</span>: <span id="gridLineWidth-value">1</span>px</label>
                                <input type="range" id="gridLineWidth" min="0" max="5" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <div>
                                <label for="gridLineColor" class="block text-sm font-medium text-gray-700 sr-only" data-lang="labelGridLineColor">枠線の色</label>
                                <input type="color" id="gridLineColor" value="#CCCCCC" class="w-full h-10 p-1 border border-gray-300 rounded-lg cursor-pointer">
                            </div>
                        </div>
                        <button id="reset-field-settings-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm"><i class="fas fa-undo mr-2"></i><span data-lang="btnResetFieldSettings">フィールド設定をリセット</span></button>
                    </div>
                </div>

                <!-- チャート設定 -->
                <div>
                    <button data-accordion-toggle="chart-settings-content" class="w-full flex justify-between items-center p-3 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors">
                        <span class="font-semibold" data-lang="chartSettingsTitle">チャート設定</span>
                        <i class="fas fa-chevron-down transition-transform"></i>
                    </button>
                    <div id="chart-settings-content" class="accordion-content mt-4 space-y-6 pl-4 border-l-2 border-gray-200">
                        <div class="grid grid-cols-2 gap-4 items-center">
                            <div>
                                <label for="chartLineWidth" class="block text-sm font-medium text-gray-700"><span data-lang="labelChartLineWidth">チャート線の太さ</span>: <span id="chartLineWidth-value">2</span>px</label>
                                <input type="range" id="chartLineWidth" min="1" max="10" value="2" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <div>
                                <label for="chartLineColor" class="block text-sm font-medium text-gray-700 sr-only" data-lang="labelChartLineColor">チャート線の色</label>
                                <input type="color" id="chartLineColor" value="#000000" class="w-full h-10 p-1 border border-gray-300 rounded-lg cursor-pointer">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4 items-center">
                             <div>
                                <label for="fillOpacity" class="block text-sm font-medium text-gray-700"><span data-lang="labelFillOpacity">塗りつぶしの透過度</span>: <span id="fillOpacity-value">30</span>%</label>
                                <input type="range" id="fillOpacity" min="0" max="100" value="30" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <div>
                                <label for="fillColor" class="block text-sm font-medium text-gray-700 sr-only" data-lang="labelFillColor">チャートの塗りつぶしの色</label>
                                <input type="color" id="fillColor" value="#000000" class="w-full h-10 p-1 border border-gray-300 rounded-lg cursor-pointer">
                            </div>
                        </div>
                        <div>
                           <label class="checkbox-label">
                               <input type="checkbox" id="showValues" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                               <span class="ml-2 text-sm font-medium text-gray-700" data-lang="labelShowValues">数値を表示</span>
                           </label>
                        </div>
                         <button id="reset-chart-settings-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm"><i class="fas fa-undo mr-2"></i><span data-lang="btnResetChartSettings">チャート設定をリセット</span></button>
                    </div>
                </div>
                
                <!-- ステータス項目設定 -->
                <div>
                    <button data-accordion-toggle="status-settings-content" class="w-full flex justify-between items-center p-3 bg-gray-100 hover:bg-gray-200 rounded-md transition-colors">
                        <span class="font-semibold" data-lang="statusSettingsTitle">ステータス項目設定</span>
                        <i class="fas fa-chevron-down transition-transform"></i>
                    </button>
                    <div id="status-settings-content" class="accordion-content mt-4 space-y-4 pl-4 border-l-2 border-gray-200">
                        <div>
                            <label for="sides" class="block text-sm font-medium text-gray-700"><span data-lang="labelSides">ステータス項目の数</span>: <span id="sides-value">5</span><span data-lang="sidesUnit"></span></label>
                            <input type="range" id="sides" min="4" max="7" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div id="status-labels-container" class="space-y-4">
                           <!-- ラベル設定が動的にここに挿入されます -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- ヘルプビュー -->
            <div id="help-view" class="hidden text-sm text-gray-700 space-y-4"></div>

            <!-- 編集ビュー -->
            <div id="edit-view" class="hidden">
                 <div class="space-y-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700" data-lang="labelEditMode">編集モード</label>
                        <select id="editMode" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                            <option value="image" data-lang="optionImage">画像</option>
                            <option value="text" data-lang="optionText">テキスト</option>
                        </select>
                    </div>
                    <!-- 画像編集用 -->
                    <div id="image-controls" class="space-y-4">
                        <div>
                            <label for="imageClip" class="block text-sm font-medium text-gray-700" data-lang="labelImageClip">画像表示方法</label>
                            <select id="imageClip" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                <option value="data" data-lang="clipData">チャート形状にクリップ</option>
                                <option value="frame" data-lang="clipFrame">グラフの枠にクリップ</option>
                                <option value="full" data-lang="clipFull">全体表示</option>
                            </select>
                        </div>
                        <div>
                            <label for="imageScale" class="block text-sm font-medium text-gray-700"><span data-lang="labelScale">拡大縮小</span>: <span id="imageScale-value">100</span>%</label>
                            <input type="range" id="imageScale" min="20" max="300" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div>
                            <label for="imageOpacity" class="block text-sm font-medium text-gray-700"><span data-lang="labelOpacity">透過度</span>: <span id="imageOpacity-value">100</span>%</label>
                            <input type="range" id="imageOpacity" min="0" max="100" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-700" data-lang="labelPosition">位置（横/縦）</label>
                            <label for="imageOffsetX" class="block text-xs text-gray-500 mt-2"><span data-lang="labelOffsetX">横</span></label>
                            <input type="range" id="imageOffsetX" min="-200" max="200" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                            <label for="imageOffsetY" class="block text-xs text-gray-500 mt-2"><span data-lang="labelOffsetY">縦</span></label>
                            <input type="range" id="imageOffsetY" min="-200" max="200" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>
                    <!-- テキスト編集用 -->
                    <div id="text-controls" class="hidden space-y-4">
                        <div>
                            <label for="textValue" class="block text-sm font-medium text-gray-700" data-lang="textContent">テキスト内容</label>
                            <textarea id="textValue" class="w-full h-24 border border-gray-300 rounded-md p-2 mt-1"></textarea>
                        </div>
                         <div>
                            <label for="textFontFamily" class="block text-sm font-medium text-gray-700" data-lang="textFontFamily">フォント</label>
                            <select id="textFontFamily" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                                <option value="Inter, 'Noto Sans JP', sans-serif">Inter (ゴシック)</option>
                                <option value="Roboto, sans-serif">Roboto (ゴシック)</option>
                                <option value="Merriweather, 'Noto Serif JP', serif">Merriweather (明朝)</option>
                                <option value="Lobster, cursive">Lobster (デザイン)</option>
                            </select>
                        </div>
                        <div class="grid grid-cols-2 gap-4 items-center">
                            <div>
                                <label for="textFontSize" class="block text-sm font-medium text-gray-700"><span data-lang="textFontSize">フォントサイズ</span>: <span id="textFontSize-value">48</span>px</label>
                                <input type="range" id="textFontSize" min="10" max="150" value="48" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-1">
                            </div>
                            <div>
                                <label for="textColor" class="block text-sm font-medium text-gray-700 sr-only" data-lang="textColor">テキストの色</label>
                                <input type="color" id="textColor" value="#000000" class="w-full h-10 p-1 border border-gray-300 rounded-lg cursor-pointer mt-1">
                            </div>
                        </div>
                        <div class="flex items-center justify-around">
                            <label class="checkbox-label">
                                <input type="checkbox" id="textFontBold" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                <span class="ml-2 text-sm font-medium text-gray-700" data-lang="textFontBold">太字</span>
                            </label>
                            <label class="checkbox-label">
                                <input type="checkbox" id="textFontItalic" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                <span class="ml-2 text-sm font-medium text-gray-700" data-lang="textFontItalic">斜体</span>
                            </label>
                             <label class="checkbox-label">
                                <input type="checkbox" id="textHasShadow" class="h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500">
                                <span class="ml-2 text-sm font-medium text-gray-700" data-lang="textHasShadow">影</span>
                            </label>
                        </div>
                        <button id="reset-text-settings-btn" class="w-full bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg transition-colors text-sm"><i class="fas fa-undo mr-2"></i><span data-lang="btnResetTextSettings">テキスト設定をリセット</span></button>
                    </div>
                </div>
            </div>

        </div>

    </aside>

    <!-- メインコンテンツ -->
    <main class="main-content p-4 md:p-8">
        <header class="bg-white p-4 rounded-lg shadow-sm mb-6 flex flex-wrap items-center justify-between gap-4">
            <h1 id="app-title" class="text-xl md:text-2xl font-bold text-gray-800" data-lang="appTitle">画像放り込みレーダーチャートメーカー</h1>
            <div class="flex items-center gap-2 flex-wrap">
                <button id="fullscreen-btn" title="全画面表示" class="menu-btn font-bold py-2 px-4 rounded-lg transition-colors"><i class="fas fa-expand"></i></button>
                <button id="export-btn" class="menu-btn font-bold py-2 px-4 rounded-lg transition-colors"><i class="fas fa-image mr-2"></i><span data-lang="export">画像出力</span></button>
                <button id="help-btn" class="menu-btn font-bold py-2 px-4 rounded-lg transition-colors"><i class="fas fa-question-circle mr-2"></i><span data-lang="help">操作方法</span></button>
                
                <div class="border-l border-gray-300 h-6 mx-2"></div>

                <button id="save-btn" class="menu-btn font-bold py-2 px-4 rounded-lg transition-colors"><i class="fas fa-save mr-2"></i><span data-lang="save">保存</span></button>
                <button id="load-btn" class="menu-btn font-bold py-2 px-4 rounded-lg transition-colors"><i class="fas fa-folder-open mr-2"></i><span data-lang="load">呼び出し</span></button>
                <input type="file" id="load-input" class="hidden" accept=".json">

                <div class="border-l border-gray-300 h-6 mx-2"></div>

                <button id="language-toggle-btn" class="menu-btn font-bold py-2 px-4 rounded-lg transition-colors"></button>
            </div>
        </header>
        <div id="canvas-container">
            <canvas id="radarCanvas"></canvas>
        </div>
    </main>
</div>

<!-- モーダルコンテナ -->
<div id="modal-container"></div>

<script>
window.onload = () => {
    // --- DOM要素 ---
    const getEl = (id) => document.getElementById(id);
    const canvas = getEl('radarCanvas');
    const ctx = canvas.getContext('2d');
    const canvasContainer = getEl('canvas-container');
    const panelTitle = getEl('panel-title');
    const backToSettingsBtn = getEl('back-to-settings-btn');
    const settingsView = getEl('settings-view');
    const helpView = getEl('help-view');
    const editView = getEl('edit-view');
    const helpBtn = getEl('help-btn');
    const modalContainer = getEl('modal-container');

    // --- 翻訳データ ---
    const translations = {
        ja: {
            appTitle: "画像放り込みレーダーチャートメーカー",
            settings: "設定", save: "保存", load: "呼び出し", export: "画像出力", help: "操作方法",
            settingsTitle: "設定",
            statusSettingsTitle: "ステータス項目設定",
            fieldSettingsTitle: "フィールド設定",
            chartSettingsTitle: "チャート設定",
            labelGraphSize: "グラフサイズ",
            graphSizeLarge: "大",
            graphSizeMedium: "中",
            graphSizeSmall: "小",
            labelBackgroundColor: "背景色",
            labelBackgroundColorOpacity: "背景の透過度",
            labelSides: "ステータス項目の数", sidesUnit: "角形",
            labelMaxValue: "ステータスの最大値",
            labelChartLineWidth: "チャート線の太さ",
            labelChartLineColor: "チャート線の色",
            labelFillColor: "チャートの塗りつぶしの色",
            labelFillOpacity: "塗りつぶしの透過度",
            labelGridLineWidth: "枠線の太さ",
            labelGridLineColor: "枠線の色",
            labelLabelText: "項目",
            labelLabelFontSize: "文字サイズ",
            labelShowValues: "数値を表示",
            btnResetFieldSettings: "フィールド設定をリセット",
            btnResetChartSettings: "チャート設定をリセット",
            btnResetTextSettings: "テキスト設定をリセット",
            exportTitle: "画像として出力",
            labelFileName: "ファイル名",
            labelExportFormat: "拡張子",
            labelExportSize: "画像サイズ",
            btnExport: "出力",
            helpTitle: "操作方法",
            editTitle: "画像/テキスト編集",
            back_to_settings: "戻る",
            labelEditMode: "編集モード",
            optionImage: "画像", optionText: "テキスト",
            labelImageClip: "画像表示方法",
            clipData: "チャート形状にクリップ", clipFrame: "グラフの枠にクリップ", clipFull: "全体表示",
            labelScale: "拡大縮小",
            labelOpacity: "透過度", 
            labelPosition: "位置（横/縦）",
            labelOffsetX: "横", 
            labelOffsetY: "縦",
            confirmTitle: "確認",
            infoTitle: "情報",
            btnNo: "いいえ", btnYes: "はい", btnOK: "OK", btnCancel: "キャンセル",
            confirmMessage: "画像を置き換えますか？",
            confirmReset: "このセクションの設定を初期値に戻します。よろしいですか？",
            invalidFile: "無効なファイル形式です。正しいJSONファイルを指定してください。",
            savePlaceholder: "チャートデータ",
            exportPlaceholder: "レーダーチャート",
            lang_toggle_en: "English",
            lang_toggle_ja: "日本語",
            textContent: "テキスト内容",
            textFontFamily: "フォント",
            textFontSize: "フォントサイズ",
            textColor: "テキストの色",
            textFontBold: "太字",
            textFontItalic: "斜体",
            textHasShadow: "影",
            fullscreenEnter: "全画面表示",
            fullscreenExit: "全画面解除",
        },
        en: {
            appTitle: "Image Drop Radar Chart Maker",
            settings: "Settings", save: "Save", load: "Load", export: "Export", help: "Help",
            settingsTitle: "Settings",
            statusSettingsTitle: "Status Item Settings",
            fieldSettingsTitle: "Field Settings",
            chartSettingsTitle: "Chart Settings",
            labelGraphSize: "Graph Size",
            graphSizeLarge: "Large",
            graphSizeMedium: "Medium",
            graphSizeSmall: "Small",
            labelBackgroundColor: "Background Color",
            labelBackgroundColorOpacity: "Background Opacity",
            labelSides: "Number of Status Items", sidesUnit: "",
            labelMaxValue: "Status Max Value",
            labelChartLineWidth: "Chart Line Width",
            labelChartLineColor: "Chart Line Color",
            labelFillColor: "Chart Fill Color",
            labelFillOpacity: "Fill Opacity",
            labelGridLineWidth: "Grid Line Width",
            labelGridLineColor: "Grid Line Color",
            labelLabelText: "Item",
            labelLabelFontSize: "Font Size",
            labelShowValues: "Show Values",
            btnResetFieldSettings: "Reset Field Settings",
            btnResetChartSettings: "Reset Chart Settings",
            btnResetTextSettings: "Reset Text Settings",
            exportTitle: "Export as Image",
            labelFileName: "File Name",
            labelExportFormat: "Format",
            labelExportSize: "Image Size",
            btnExport: "Export",
            helpTitle: "How to Use",
            editTitle: "Edit Image/Text",
            back_to_settings: "Back",
            labelEditMode: "Edit Mode",
            optionImage: "Image", optionText: "Text",
            labelImageClip: "Image Display Method",
            clipData: "Clip to data shape", clipFrame: "Clip to chart frame", clipFull: "Show full image",
            labelScale: "Scale",
            labelOpacity: "Opacity", 
            labelPosition: "Position (H/V)",
            labelOffsetX: "Horizontal", 
            labelOffsetY: "Vertical",
            confirmTitle: "Confirm",
            infoTitle: "Information",
            btnNo: "No", btnYes: "Yes", btnOK: "OK", btnCancel: "Cancel",
            confirmMessage: "Do you want to replace the image?",
            confirmReset: "Are you sure you want to reset the settings in this section?",
            invalidFile: "Invalid file format. Please specify a correct JSON file.",
            savePlaceholder: "ChartData",
            exportPlaceholder: "RadarChart",
            lang_toggle_en: "English",
            lang_toggle_ja: "日本語",
            textContent: "Text Content",
            textFontFamily: "Font",
            textFontSize: "Font Size",
            textColor: "Text Color",
            textFontBold: "Bold",
            textFontItalic: "Italic",
            textHasShadow: "Shadow",
            fullscreenEnter: "Fullscreen",
            fullscreenExit: "Exit Fullscreen",
        }
    };

    function getHelpContent(lang) {
        return lang === 'ja' ? `
            <h3 class="font-semibold mb-2">画像の設定</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>画像の読込:</strong> PCから右側のチャートエリアに画像をドラッグ＆ドロップします。</li>
                <li><strong>画像の変更:</strong> 新しい画像をドラッグ＆ドロップすると変更できます。</li>
            </ul>
            <h3 class="font-semibold mt-4 mb-2">チャートの編集</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>数値の変更:</strong> チャート上の黒い点をドラッグします。</li>
                <li><strong>項目名の変更:</strong> 左パネルの「ステータス項目設定」からテキストやスタイルを編集します。</li>
                <li><strong>画像/テキストの調整:</strong> チャートエリア内をダブルクリックすると左パネルが編集モードに切り替わります。</li>
            </ul>
            <h3 class="font-semibold mt-4 mb-2">設定のカスタマイズ</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>各種設定:</strong> 左側の設定パネルで、チャートの形、色、線の太さなどを変更できます。設定は自動で保存されます。</li>
                <li><strong>全画面表示:</strong> ヘッダーのボタンから全画面表示の切り替えができます。OBSのウィンドウキャプチャで利用する際は、この機能でブラウザのUI（URLバーなど）を非表示にすることをおすすめします。</li>
            </ul>
        ` : `
            <h3 class="font-semibold mb-2">Image Settings</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>Load Image:</strong> Drag & drop an image from your PC to the chart area on the right.</li>
                <li><strong>Change Image:</strong> You can change the image by dragging & dropping a new one.</li>
            </ul>
            <h3 class="font-semibold mt-4 mb-2">Chart Editing</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>Change Values:</strong> Drag the black dots on the chart.</li>
                <li><strong>Change Labels:</strong> Edit text and styles from the "Status Item Settings" section in the left panel.</li>
                <li><strong>Adjust Image/Text:</strong> Double-click inside the chart area to switch the left panel to edit mode.</li>
            </ul>
            <h3 class="font-semibold mt-4 mb-2">Customization</h3>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>Various Settings:</strong> Change the chart's shape, colors, line widths, etc., in the 'Settings' panel. Settings are saved automatically.</li>
                <li><strong>Fullscreen Mode:</strong> You can toggle fullscreen mode from the button in the header. When using with window capture in OBS, we recommend using this feature to hide the browser UI (URL bar, etc.).</li>
            </ul>
        `;
    }

    // --- 状態管理 ---
    let state = {};
    let chartGeometry = {};
    let history = [];
    let historyIndex = -1;
    let isApplyingState = false;
    
    function getDefaultTextSettings() {
        return {
            value: '',
            fontSize: 48,
            fontFamily: "Inter, 'Noto Sans JP', sans-serif",
            color: '#000000',
            isBold: false,
            isItalic: false,
            hasShadow: false,
        };
    }
    
    function getDefaultSettings() {
        return {
            language: 'ja',
            graphSize: 'large',
            backgroundColor: '#FFFFFF',
            backgroundColorOpacity: 1,
            sides: 5, 
            maxValue: 5, 
            gridLineWidth: 1, 
            gridLineColor: '#cccccc', 
            chartLineWidth: 2, 
            chartLineColor: '#000000',
            fillColor: '#000000',
            fillOpacity: 0.3, 
            showValues: false,
            imageClip: 'full',
        };
    }
    
    function getDefaultLabel(text = 'A') {
        return {
            text: text,
            fontSize: 20,
            color: '#333333',
            isBold: false,
            isItalic: false,
            hasShadow: false,
        };
    }

    function resetState() {
        state = {
            settings: getDefaultSettings(),
            chartData: {
                labels: [
                    getDefaultLabel('A'), getDefaultLabel('B'), getDefaultLabel('C'),
                    getDefaultLabel('D'), getDefaultLabel('E')
                ],
                values: [1, 1, 1, 1, 1],
            },
            image: {
                element: null, name: '', opacity: 1.0, offsetX: 0, offsetY: 0, scale: 1.0,
            },
            text: getDefaultTextSettings(),
            editMode: 'image',
            draggingPoint: -1,
        }
    }

    // --- 初期化 ---
    function init() {
        resetState();
        loadSettings();
        setupEventListeners();
        showPanelView('settings');
        updateLanguage();
        updateContainerBackground();
        resizeCanvas();
        updateChartData(state.settings.sides);
        updateStatusLabelsUI();
        updateAllSettings(false); 
        saveStateToHistory();
    }

    // --- パネルビュー管理 ---
    function showPanelView(view) {
        settingsView.classList.add('hidden');
        helpView.classList.add('hidden');
        editView.classList.add('hidden');
        backToSettingsBtn.classList.add('hidden');
        
        document.querySelectorAll('.menu-btn.active-help').forEach(b => b.classList.remove('active-help'));

        if (view === 'settings') {
            panelTitle.textContent = t('settingsTitle');
            settingsView.classList.remove('hidden');
        } else if (view === 'help') {
            panelTitle.textContent = t('helpTitle');
            helpView.innerHTML = getHelpContent(state.settings.language);
            helpView.classList.remove('hidden');
            backToSettingsBtn.classList.remove('hidden');
            helpBtn.classList.add('active-help');
        } else if (view === 'edit') {
            panelTitle.textContent = t('editTitle');
            editView.classList.remove('hidden');
            backToSettingsBtn.classList.remove('hidden');
            updateEditViewUI();
        }
    }

    // --- 言語設定 ---
    function t(key) { return translations[state.settings.language][key] || key; }
    function updateLanguage() {
        const lang = state.settings.language;
        document.documentElement.lang = lang;
        document.querySelectorAll('[data-lang]').forEach(el => {
            const key = el.dataset.lang;
            if (translations[lang] && translations[lang][key]) {
                const icon = el.querySelector('i');
                const span = el.querySelector('span');
                 if (icon && span) {
                    span.textContent = ` ${translations[lang][key]}`;
                } else {
                    el.textContent = translations[lang][key];
                }
            }
        });
        
        getEl('language-toggle-btn').textContent = lang === 'ja' ? t('lang_toggle_en') : t('lang_toggle_ja');

        const sidesUnitEl = document.querySelector('span[data-lang="sidesUnit"]');
        if (sidesUnitEl) {
            sidesUnitEl.textContent = lang === 'ja' ? `角形` : '';
        }
        if (!settingsView.classList.contains('hidden')) showPanelView('settings');
        else if (!helpView.classList.contains('hidden')) showPanelView('help');
        else if (!editView.classList.contains('hidden')) showPanelView('edit');
        
        updateStatusLabelsUI(); // Re-render labels for language change
        updateFullscreenButton();
    }

    // --- キャンバスのリサイズ ---
    function resizeCanvas() {
        const rect = canvasContainer.getBoundingClientRect();
        const size = Math.min(rect.width, rect.height);
        canvas.width = size;
        canvas.height = size;
        draw();
    }
    window.addEventListener('resize', resizeCanvas);

    // --- 設定の更新と保存 ---
    function updateAllSettings(saveHistory = true) {
        const previousGraphSize = state.settings.graphSize;
        
        state.settings.graphSize = document.querySelector('input[name="graphSize"]:checked').value;
        state.settings.backgroundColor = getEl('backgroundColor').value;
        state.settings.backgroundColorOpacity = parseInt(getEl('backgroundColorOpacity').value) / 100;
        const previousSides = state.settings.sides;
        state.settings.sides = parseInt(getEl('sides').value);
        state.settings.maxValue = parseInt(getEl('maxValue').value);
        state.settings.chartLineWidth = parseInt(getEl('chartLineWidth').value);
        state.settings.chartLineColor = getEl('chartLineColor').value;
        state.settings.gridLineWidth = parseInt(getEl('gridLineWidth').value);
        state.settings.gridLineColor = getEl('gridLineColor').value;
        state.settings.fillColor = getEl('fillColor').value;
        state.settings.fillOpacity = parseInt(getEl('fillOpacity').value) / 100;
        state.settings.showValues = getEl('showValues').checked;
        state.settings.imageClip = getEl('imageClip').value;
        
        updateValueDisplays();
        updateContainerBackground();
        
        if (state.settings.sides !== previousSides) {
            updateChartData(state.settings.sides);
            updateStatusLabelsUI();
        }

        saveSettings();
        
        if (state.settings.graphSize !== previousGraphSize) {
            resizeCanvas();
        } else {
            draw();
        }
        
        if(saveHistory) saveStateToHistory();
    }
    
    function updateValueDisplays() {
        getEl('backgroundColorOpacity-value').textContent = getEl('backgroundColorOpacity').value;
        getEl('sides-value').textContent = getEl('sides').value;
        getEl('maxValue-value').textContent = getEl('maxValue').value;
        getEl('chartLineWidth-value').textContent = getEl('chartLineWidth').value;
        getEl('gridLineWidth-value').textContent = getEl('gridLineWidth').value;
        getEl('fillOpacity-value').textContent = getEl('fillOpacity').value;
        getEl('imageScale-value').textContent = getEl('imageScale').value;
        getEl('imageOpacity-value').textContent = getEl('imageOpacity').value;
        getEl('textFontSize-value').textContent = getEl('textFontSize').value;
        
        document.querySelectorAll('.label-font-size-value').forEach(el => {
            const index = el.dataset.index;
            if(state.chartData.labels[index]) {
                el.textContent = state.chartData.labels[index].fontSize;
            }
        });
    }

    function saveSettings() {
        localStorage.setItem('radarChartSettingsUnified', JSON.stringify(state.settings));
        localStorage.setItem('radarChartAccordion', JSON.stringify({
            status: getEl('status-settings-content').classList.contains('open'),
            field: getEl('field-settings-content').classList.contains('open'),
            chart: getEl('chart-settings-content').classList.contains('open')
        }));
    }

    function loadSettings() {
        const savedSettings = localStorage.getItem('radarChartSettingsUnified');
        const defaultSettings = getDefaultSettings();
        if (savedSettings) {
            state.settings = { ...defaultSettings, ...JSON.parse(savedSettings) };
        } else {
            state.settings = defaultSettings;
        }
        updateSettingsUI();
    }

    function updateSettingsUI() {
        document.querySelector(`input[name="graphSize"][value="${state.settings.graphSize}"]`).checked = true;
        Object.keys(state.settings).forEach(key => {
            const el = getEl(key);
            if(el) {
                if (el.type === 'checkbox') {
                    el.checked = state.settings[key];
                } else if (key === 'fillOpacity' || key === 'backgroundColorOpacity') {
                    el.value = state.settings[key] * 100;
                } else if (key !== 'graphSize') { 
                    el.value = state.settings[key];
                }
            }
        });
        updateValueDisplays();
    }
    
    function updateContainerBackground() {
        canvasContainer.style.backgroundColor = hexToRgba(state.settings.backgroundColor, state.settings.backgroundColorOpacity);
    }

    // --- チャートデータの更新 ---
    function updateChartData(newSides) {
        const defaultLabels = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
        const currentLength = state.chartData.labels.length;

        if (newSides > currentLength) {
            for (let i = currentLength; i < newSides; i++) {
                state.chartData.labels.push(getDefaultLabel(defaultLabels[i % defaultLabels.length]));
                state.chartData.values.push(1);
            }
        } else if (newSides < currentLength) {
            state.chartData.labels.splice(newSides);
            state.chartData.values.splice(newSides);
        }
    }
    
    function drawOnContext(targetCtx, width, height, geometry) {
        // Clear canvas before drawing chart content
        targetCtx.clearRect(0, 0, width, height);

        const { cx, cy, r, textCenterX, textCenterY, maxTextWidth } = geometry;

        if (state.editMode === 'image' && state.image.element) {
            drawImage(targetCtx, cx, cy, r);
        } else if (state.editMode === 'text' && state.text.value) {
            drawText(targetCtx, textCenterX, textCenterY, maxTextWidth);
        }
        
        drawGrid(targetCtx, cx, cy, r);
        drawChart(targetCtx, cx, cy, r);
        drawLabels(targetCtx, cx, cy, r);
        drawPoints(targetCtx, cx, cy, r);
    }

    // --- 描画処理 ---
    function draw() {
        const width = canvas.width;
        const height = canvas.height;
        const geometry = calculateGeometry(width, height);
        chartGeometry = geometry;
        drawOnContext(ctx, width, height, geometry);
    }

    function drawBackground(targetCtx, width, height, options = {}) {
        const opacity = options.forceOpaqueBackground ? 1.0 : state.settings.backgroundColorOpacity;
        targetCtx.fillStyle = hexToRgba(state.settings.backgroundColor, opacity);
        targetCtx.fillRect(0, 0, width, height);
    }

    function calculateGeometry(width, height) {
        const cx = width / 2;
        const cy = height / 2;
        const baseRadius = Math.min(width, height) / 2;

        let radiusMultiplier;
        switch (state.settings.graphSize) {
            case 'medium':
                radiusMultiplier = 0.65;
                break;
            case 'small':
                radiusMultiplier = 0.55;
                break;
            case 'large':
            default:
                radiusMultiplier = 0.75;
                break;
        }
        const r = baseRadius * radiusMultiplier;

        return {
            cx: cx,
            cy: cy,
            r: r,
            textCenterX: cx,
            textCenterY: cy,
            maxTextWidth: r * 1.8,
        };
    }
    
    function drawImage(targetCtx, cx, cy, r) {
        targetCtx.save();
        if (state.settings.imageClip === 'frame' || state.settings.imageClip === 'data') {
            targetCtx.beginPath();
            for (let i = 0; i < state.settings.sides; i++) {
                let clipRadius = (state.settings.imageClip === 'frame') ? r : (r / state.settings.maxValue) * state.chartData.values[i];
                const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
                const x = cx + clipRadius * Math.cos(angle);
                const y = cy + clipRadius * Math.sin(angle);
                if (i === 0) targetCtx.moveTo(x, y);
                else targetCtx.lineTo(x, y);
            }
            targetCtx.closePath();
            targetCtx.clip();
        }

        const img = state.image.element;
        const polyWidth = r * 2;
        const polyHeight = r * 2;
        let drawWidth, drawHeight;
        const imgAspectRatio = img.width / img.height;
        
        if (imgAspectRatio > 1) {
            drawHeight = polyHeight;
            drawWidth = drawHeight * imgAspectRatio;
        } else {
            drawWidth = polyWidth;
            drawHeight = drawWidth / imgAspectRatio;
        }
        
        drawWidth *= state.image.scale;
        drawHeight *= state.image.scale;

        const dx = cx - drawWidth / 2 + state.image.offsetX;
        const dy = cy - drawHeight / 2 + state.image.offsetY;

        targetCtx.globalAlpha = state.image.opacity;
        targetCtx.drawImage(img, dx, dy, drawWidth, drawHeight);
        targetCtx.restore();
    }

    function drawText(targetCtx, cx, cy, maxTextWidth) {
        targetCtx.save();
        const txt = state.text;
        targetCtx.textAlign = 'center';
        targetCtx.textBaseline = 'middle';
        targetCtx.fillStyle = txt.color;
        
        const fontStyle = txt.isItalic ? 'italic' : 'normal';
        const fontWeight = txt.isBold ? 'bold' : 'normal';
        targetCtx.font = `${fontStyle} ${fontWeight} ${txt.fontSize}px "${txt.fontFamily.split(',')[0]}"`;

        if (txt.hasShadow) {
            targetCtx.shadowColor = 'rgba(0,0,0,0.5)';
            targetCtx.shadowBlur = 5;
            targetCtx.shadowOffsetX = 2;
            targetCtx.shadowOffsetY = 2;
        }

        const textToDraw = txt.value;
        const textWidth = targetCtx.measureText(textToDraw).width;
        
        if(textWidth > maxTextWidth){
            const scale = maxTextWidth / textWidth;
            targetCtx.font = `${fontStyle} ${fontWeight} ${txt.fontSize * scale}px "${txt.fontFamily.split(',')[0]}"`;
        }

        targetCtx.fillText(textToDraw, cx, cy);
        targetCtx.restore();
    }

    function drawGrid(targetCtx, cx, cy, r) {
        if (state.settings.gridLineWidth <= 0) return;
        targetCtx.strokeStyle = state.settings.gridLineColor;
        targetCtx.lineWidth = state.settings.gridLineWidth;
        for (let j = 1; j <= state.settings.maxValue; j++) {
            const currentRadius = (r / state.settings.maxValue) * j;
            targetCtx.beginPath();
            for (let i = 0; i < state.settings.sides; i++) {
                const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
                const x = cx + currentRadius * Math.cos(angle);
                const y = cy + currentRadius * Math.sin(angle);
                if (i === 0) targetCtx.moveTo(x, y);
                else targetCtx.lineTo(x, y);
            }
            targetCtx.closePath();
            targetCtx.stroke();
        }
        for (let i = 0; i < state.settings.sides; i++) {
            const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
            targetCtx.beginPath();
            targetCtx.moveTo(cx, cy);
            targetCtx.lineTo(cx + r * Math.cos(angle), cy + r * Math.sin(angle));
            targetCtx.stroke();
        }
    }

    function drawChart(targetCtx, cx, cy, r) {
        targetCtx.strokeStyle = state.settings.chartLineColor;
        targetCtx.fillStyle = hexToRgba(state.settings.fillColor, state.settings.fillOpacity);
        targetCtx.lineWidth = state.settings.chartLineWidth;
        targetCtx.beginPath();
        for (let i = 0; i < state.settings.sides; i++) {
            const value = state.chartData.values[i];
            const currentRadius = (r / state.settings.maxValue) * value;
            const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
            const x = cx + currentRadius * Math.cos(angle);
            const y = cy + currentRadius * Math.sin(angle);
            if (i === 0) targetCtx.moveTo(x, y);
            else targetCtx.lineTo(x, y);
        }
        targetCtx.closePath();
        targetCtx.stroke();
        targetCtx.fill();
    }

    function drawLabels(targetCtx, cx, cy, r) {
        targetCtx.textAlign = 'center';
        targetCtx.textBaseline = 'middle';
        
        const labelRadius = r * 1.15;
        for (let i = 0; i < state.settings.sides; i++) {
            targetCtx.save();

            const label = state.chartData.labels[i];
            const value = state.chartData.values[i];
            const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
            
            let x = cx + labelRadius * Math.cos(angle);
            let y = cy + labelRadius * Math.sin(angle);

            if (i === 0) { // Top label
                y -= label.fontSize * 0.5;
            }

            const fontStyle = label.isItalic ? 'italic' : 'normal';
            const fontWeight = label.isBold ? 'bold' : 'normal';
            targetCtx.font = `${fontStyle} ${fontWeight} ${label.fontSize}px sans-serif`;
            
            targetCtx.fillStyle = label.color;

            if (label.hasShadow) {
                targetCtx.shadowColor = 'rgba(0,0,0,0.5)';
                targetCtx.shadowBlur = 3;
                targetCtx.shadowOffsetX = 1;
                targetCtx.shadowOffsetY = 1;
            }
            
            targetCtx.fillText(label.text, x, y);
            
            targetCtx.shadowColor = 'transparent';

            if (state.settings.showValues) {
                targetCtx.font = `${label.fontSize * 0.8}px sans-serif`;
                targetCtx.fillText(`(${value})`, x, y + label.fontSize * 1.1);
            }

            targetCtx.restore();
        }
    }

    function drawPoints(targetCtx, cx, cy, r) {
        for (let i = 0; i < state.settings.sides; i++) {
            const value = state.chartData.values[i];
            const currentRadius = (r / state.settings.maxValue) * value;
            const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
            const x = cx + currentRadius * Math.cos(angle);
            const y = cy + currentRadius * Math.sin(angle);
            targetCtx.beginPath();
            targetCtx.arc(x, y, 5, 0, 2 * Math.PI);
            targetCtx.fillStyle = state.settings.chartLineColor;
            targetCtx.fill();
        }
    }
    
    // --- イベントリスナー設定 ---
    function setupEventListeners() {
        // Header buttons
        getEl('fullscreen-btn').addEventListener('click', toggleFullscreen);
        helpBtn.addEventListener('click', () => showPanelView('help'));
        getEl('save-btn').addEventListener('click', showSaveModal);
        getEl('load-btn').addEventListener('click', () => getEl('load-input').click());
        getEl('load-input').addEventListener('change', loadChartData);
        getEl('export-btn').addEventListener('click', showExportModal);
        getEl('language-toggle-btn').addEventListener('click', () => {
            state.settings.language = state.settings.language === 'ja' ? 'en' : 'ja';
            updateLanguage();
            saveSettings();
        });
        
        // Panel controls
        backToSettingsBtn.addEventListener('click', () => showPanelView('settings'));

        // Accordion
        document.querySelectorAll('[data-accordion-toggle]').forEach(button => {
            button.addEventListener('click', () => {
                const contentId = button.getAttribute('data-accordion-toggle');
                toggleAccordion(contentId);
                saveSettings();
            });
        });

        // Settings view inputs
        const allRangeInputs = document.querySelectorAll('#settings-view input[type="range"], #edit-view input[type="range"]');
        allRangeInputs.forEach(input => {
            input.addEventListener('input', () => {
                updateValueDisplays();
                if (input.id.startsWith('image')) {
                    updateImageSettings(false);
                } else if (input.id.startsWith('text')) {
                    updateTextSettings(false);
                } else {
                    updateAllSettings(false);
                }
            });
            input.addEventListener('change', (e) => {
                e.target.blur();
                saveStateToHistory();
            });
        });
        
        const allChangeInputs = document.querySelectorAll('#settings-view input[type="color"], #settings-view input[type="radio"], #settings-view input[type="checkbox"], #edit-view select, #edit-view input[type="color"], #edit-view input[type="checkbox"], #edit-view textarea');
        allChangeInputs.forEach(input => {
            const eventType = (input.type === 'checkbox' || input.type === 'radio' || input.tagName === 'SELECT') ? 'change' : 'input';
            input.addEventListener(eventType, () => {
                if (input.id.startsWith('image')) {
                    updateImageSettings();
                } else if (input.id.startsWith('text')) {
                    updateTextSettings();
                } else if (input.id === 'editMode') {
                    state.editMode = input.value;
                    toggleEditControls();
                    draw();
                    saveStateToHistory();
                } else {
                    updateAllSettings();
                }
            });
        });

        // Reset buttons
        getEl('reset-field-settings-btn').addEventListener('click', () => {
            showConfirmDialog(t('confirmReset'), () => {
                const defaults = getDefaultSettings();
                const fieldKeys = ['graphSize', 'backgroundColor', 'backgroundColorOpacity', 'maxValue', 'gridLineWidth', 'gridLineColor'];
                fieldKeys.forEach(key => state.settings[key] = defaults[key]);
                updateSettingsUI();
                updateAllSettings();
            });
        });
        getEl('reset-chart-settings-btn').addEventListener('click', () => {
             showConfirmDialog(t('confirmReset'), () => {
                const defaults = getDefaultSettings();
                const chartKeys = ['chartLineWidth', 'chartLineColor', 'fillColor', 'fillOpacity', 'showValues'];
                chartKeys.forEach(key => state.settings[key] = defaults[key]);
                updateSettingsUI();
                updateAllSettings();
            });
        });
        getEl('reset-text-settings-btn').addEventListener('click', () => {
            showConfirmDialog(t('confirmReset'), () => {
                state.text = getDefaultTextSettings();
                updateEditViewUI();
                updateTextSettings();
            });
        });

        // Drag & Drop
        canvasContainer.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); canvasContainer.classList.add('drag-over'); });
        canvasContainer.addEventListener('dragleave', (e) => { e.preventDefault(); e.stopPropagation(); canvasContainer.classList.remove('drag-over'); });
        canvasContainer.addEventListener('drop', handleImageDrop);

        // Canvas interaction
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('dblclick', handleDoubleClick);

        // Undo/Redo
        document.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
                return;
            }

            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const isUndo = (isMac ? e.metaKey : e.ctrlKey) && e.key === 'z' && !e.shiftKey;
            const isRedo = (isMac ? e.metaKey && e.shiftKey : e.ctrlKey) && e.key === 'y' || (isMac && e.metaKey && e.shiftKey && e.key === 'z');

            if (isUndo) {
                e.preventDefault();
                undo();
            } else if (isRedo) {
                e.preventDefault();
                redo();
            }
        });
        
        document.addEventListener('fullscreenchange', updateFullscreenButton);
    }
    
    function toggleAccordion(contentId, forceOpen = null) {
        const content = getEl(contentId);
        const button = document.querySelector(`[data-accordion-toggle="${contentId}"]`);
        const icon = button.querySelector('i');
        const isOpen = content.classList.contains('open');

        if (forceOpen === true || (forceOpen === null && !isOpen)) {
            content.classList.add('open');
            icon.classList.remove('fa-chevron-down');
            icon.classList.add('fa-chevron-up');
        } else if (forceOpen === false || (forceOpen === null && isOpen)) {
            content.classList.remove('open');
            icon.classList.add('fa-chevron-down');
            icon.classList.remove('fa-chevron-up');
        }
    }
    
    // --- 画像処理 ---
    function handleImageDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        canvasContainer.classList.remove('drag-over');
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith('image/')) {
            if (state.image.element) {
                showConfirmDialog(t('confirmMessage'), () => loadImage(file));
            } else {
                loadImage(file);
            }
        }
    }

    function loadImage(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                state.image.element = img;
                state.image.name = file.name.split('.').slice(0, -1).join('.');
                state.image.scale = 1.0;
                state.settings.imageClip = 'full';
                saveSettings();
                state.editMode = 'image';
                draw();
                saveStateToHistory();
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    // --- キャンバスインタラクション ---
    function getMousePos(e) { const rect = canvas.getBoundingClientRect(); return { x: e.clientX - rect.left, y: e.clientY - rect.top }; }

    function handleMouseDown(e) {
        const pos = getMousePos(e);
        const { cx, cy, r } = chartGeometry;
        for (let i = 0; i < state.settings.sides; i++) {
            const value = state.chartData.values[i];
            const currentRadius = (r / state.settings.maxValue) * value;
            const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
            const pointX = cx + currentRadius * Math.cos(angle);
            const pointY = cy + currentRadius * Math.sin(angle);
            const distance = Math.sqrt(Math.pow(pos.x - pointX, 2) + Math.pow(pos.y - pointY, 2));
            if (distance < 10) { state.draggingPoint = i; canvas.style.cursor = 'grabbing'; return; }
        }
    }

    function handleMouseMove(e) {
        const pos = getMousePos(e);
        const { cx, cy, r } = chartGeometry;
        if (state.draggingPoint === -1) {
            let onPoint = false;
            for (let i = 0; i < state.settings.sides; i++) {
                const value = state.chartData.values[i];
                const currentRadius = (r / state.settings.maxValue) * value;
                const angle = (i / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
                const pointX = cx + currentRadius * Math.cos(angle);
                const pointY = cy + currentRadius * Math.sin(angle);
                const distance = Math.sqrt(Math.pow(pos.x - pointX, 2) + Math.pow(pos.y - pointY, 2));
                if (distance < 10) { onPoint = true; break; }
            }
            canvas.style.cursor = onPoint ? 'grab' : 'crosshair';
            return;
        }
        
        const dx = pos.x - cx;
        const dy = pos.y - cy;
        const targetAngle = (state.draggingPoint / state.settings.sides) * 2 * Math.PI - Math.PI / 2;
        const distanceOnAxis = (dx * Math.cos(targetAngle) + dy * Math.sin(targetAngle));
        let value = (distanceOnAxis / r) * state.settings.maxValue;
        value = Math.max(0, Math.min(state.settings.maxValue, Math.round(value)));
        state.chartData.values[state.draggingPoint] = value;
        draw();
    }

    function handleMouseUp() { 
        if (state.draggingPoint !== -1) {
            saveStateToHistory();
        }
        state.draggingPoint = -1; 
        canvas.style.cursor = 'crosshair'; 
    }

    function handleDoubleClick(e) {
        const pos = getMousePos(e);
        const { cx, cy, r } = chartGeometry;
        const distance = Math.sqrt(Math.pow(pos.x - cx, 2) + Math.pow(pos.y - cy, 2));
        if (distance < r) { showPanelView('edit'); }
    }
    
    // --- ステータス項目UI制御 ---
    function updateStatusLabelsUI() {
        const container = getEl('status-labels-container');
        container.innerHTML = ''; // Clear existing controls

        state.chartData.labels.forEach((label, index) => {
            const controlIdPrefix = `label-${index}`;
            const controlHTML = `
                <div class="p-3 border border-gray-200 rounded-md space-y-3">
                    <div class="flex items-center space-x-2">
                        <label for="${controlIdPrefix}-text" class="text-sm font-medium text-gray-700 whitespace-nowrap">${t('labelLabelText')} ${index + 1}:</label>
                        <input type="text" id="${controlIdPrefix}-text" data-index="${index}" value="${label.text}" class="w-full border border-gray-300 rounded-md shadow-sm py-1 px-2 text-sm">
                    </div>
                    <div class="grid grid-cols-2 gap-4 items-center">
                        <div>
                            <label for="${controlIdPrefix}-fontSize" class="block text-sm font-medium text-gray-700">
                                <span data-lang="labelLabelFontSize">${t('labelLabelFontSize')}</span>: 
                                <span class="label-font-size-value" data-index="${index}">${label.fontSize}</span>px
                            </label>
                            <input type="range" id="${controlIdPrefix}-fontSize" data-index="${index}" min="1" max="60" value="${label.fontSize}" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-1">
                        </div>
                        <div>
                            <label for="${controlIdPrefix}-color" class="block text-sm font-medium text-gray-700 sr-only">${t('textColor')}</label>
                            <input type="color" id="${controlIdPrefix}-color" data-index="${index}" value="${label.color}" class="w-full h-10 p-1 border border-gray-300 rounded-lg cursor-pointer">
                        </div>
                    </div>
                    <div class="flex items-center justify-around text-sm">
                        <label class="checkbox-label"><input type="checkbox" id="${controlIdPrefix}-bold" data-index="${index}" ${label.isBold ? 'checked' : ''} class="h-4 w-4 text-indigo-600 border-gray-300 rounded"><span class="ml-1" data-lang="textFontBold">${t('textFontBold')}</span></label>
                        <label class="checkbox-label"><input type="checkbox" id="${controlIdPrefix}-italic" data-index="${index}" ${label.isItalic ? 'checked' : ''} class="h-4 w-4 text-indigo-600 border-gray-300 rounded"><span class="ml-1" data-lang="textFontItalic">${t('textFontItalic')}</span></label>
                        <label class="checkbox-label"><input type="checkbox" id="${controlIdPrefix}-shadow" data-index="${index}" ${label.hasShadow ? 'checked' : ''} class="h-4 w-4 text-indigo-600 border-gray-300 rounded"><span class="ml-1" data-lang="textHasShadow">${t('textHasShadow')}</span></label>
                    </div>
                </div>
            `;
            container.insertAdjacentHTML('beforeend', controlHTML);
        });

        // Add event listeners to the new controls
        container.querySelectorAll('input').forEach(input => {
            const index = parseInt(input.dataset.index, 10);
            if (input.type === 'text') {
                input.addEventListener('input', (e) => {
                    state.chartData.labels[index].text = e.target.value;
                    draw();
                });
                input.addEventListener('change', () => saveStateToHistory());
            } else if (input.type === 'range') {
                input.addEventListener('input', (e) => {
                    state.chartData.labels[index].fontSize = parseInt(e.target.value, 10);
                    updateValueDisplays();
                    draw();
                });
                input.addEventListener('change', () => saveStateToHistory());
            } else if (input.type === 'checkbox') {
                input.addEventListener('change', (e) => {
                    if (e.target.id.endsWith('-bold')) state.chartData.labels[index].isBold = e.target.checked;
                    if (e.target.id.endsWith('-italic')) state.chartData.labels[index].isItalic = e.target.checked;
                    if (e.target.id.endsWith('-shadow')) state.chartData.labels[index].hasShadow = e.target.checked;
                    draw();
                    saveStateToHistory();
                });
            } else if (input.type === 'color') {
                 input.addEventListener('input', (e) => {
                    state.chartData.labels[index].color = e.target.value;
                    draw();
                });
                input.addEventListener('change', () => saveStateToHistory());
            }
        });
    }

    // --- 編集ビュー制御 ---
    function updateEditViewUI() {
        getEl('editMode').value = state.editMode;
        // Image controls
        getEl('imageClip').value = state.settings.imageClip;
        getEl('imageScale').value = state.image.scale * 100;
        getEl('imageOpacity').value = state.image.opacity * 100;
        getEl('imageOffsetX').value = state.image.offsetX;
        getEl('imageOffsetY').value = state.image.offsetY;
        // Text controls
        const txt = state.text;
        getEl('textValue').value = txt.value;
        getEl('textFontFamily').value = txt.fontFamily;
        getEl('textFontSize').value = txt.fontSize;
        getEl('textColor').value = txt.color;
        getEl('textFontBold').checked = txt.isBold;
        getEl('textFontItalic').checked = txt.isItalic;
        getEl('textHasShadow').checked = txt.hasShadow;

        updateValueDisplays();
        toggleEditControls();
    }

    function toggleEditControls() {
        if (state.editMode === 'image') {
            getEl('image-controls').classList.remove('hidden');
            getEl('text-controls').classList.add('hidden');
        } else {
            getEl('image-controls').classList.add('hidden');
            getEl('text-controls').classList.remove('hidden');
        }
    }

    function updateImageSettings(saveHistory = true) {
        state.image.opacity = parseInt(getEl('imageOpacity').value) / 100;
        state.image.offsetX = parseInt(getEl('imageOffsetX').value);
        state.image.offsetY = parseInt(getEl('imageOffsetY').value);
        state.image.scale = parseInt(getEl('imageScale').value) / 100;
        state.settings.imageClip = getEl('imageClip').value;
        updateValueDisplays();
        draw();
        if(saveHistory) saveStateToHistory();
    }
    
    function updateTextSettings(saveHistory = true) {
        state.text.value = getEl('textValue').value;
        state.text.fontFamily = getEl('textFontFamily').value;
        state.text.fontSize = parseInt(getEl('textFontSize').value);
        state.text.color = getEl('textColor').value;
        state.text.isBold = getEl('textFontBold').checked;
        state.text.isItalic = getEl('textFontItalic').checked;
        state.text.hasShadow = getEl('textHasShadow').checked;
        updateValueDisplays();
        draw();
        if(saveHistory) saveStateToHistory();
    }

    // --- モーダル制御 ---
    function closeModal() {
        modalContainer.innerHTML = '';
    }

    function showConfirmDialog(message, onConfirm) {
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.innerHTML = `
            <div class="modal-content w-full max-w-sm">
                <h3 class="text-lg font-medium">${t('confirmTitle')}</h3>
                <p class="mt-2 text-sm text-gray-600">${message}</p>
                <div class="mt-4 flex justify-end space-x-2">
                    <button id="confirmNo" class="px-4 py-2 bg-gray-200 rounded-md">${t('btnNo')}</button>
                    <button id="confirmYes" class="px-4 py-2 bg-red-600 text-white rounded-md">${t('btnYes')}</button>
                </div>
            </div>`;
        
        modal.querySelector('#confirmYes').addEventListener('click', () => {
            onConfirm();
            closeModal();
        });
        modal.querySelector('#confirmNo').addEventListener('click', closeModal);
        modal.addEventListener('click', (e) => { if(e.target === modal) closeModal(); });
        
        modalContainer.appendChild(modal);
    }

    function showMessageModal(message) {
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.innerHTML = `
            <div class="modal-content w-full max-w-sm">
                <h3 class="text-lg font-medium">${t('infoTitle')}</h3>
                <p class="mt-2 text-sm text-gray-600">${message}</p>
                <div class="mt-4 flex justify-end">
                    <button id="confirmOK" class="px-4 py-2 bg-indigo-600 text-white rounded-md">${t('btnOK')}</button>
                </div>
            </div>`;
        
        modal.querySelector('#confirmOK').addEventListener('click', closeModal);
        modal.addEventListener('click', (e) => { if(e.target === modal) closeModal(); });
        
        modalContainer.appendChild(modal);
    }

    function showPromptModal(message, defaultValue, onConfirm) {
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.innerHTML = `
            <div class="modal-content w-full max-w-sm">
                <h3 class="text-lg font-medium">${message}</h3>
                <input type="text" id="promptInput" value="${defaultValue}" class="mt-2 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                <div class="mt-4 flex justify-end space-x-2">
                    <button id="promptCancel" class="px-4 py-2 bg-gray-200 rounded-md">${t('btnCancel')}</button>
                    <button id="promptOK" class="px-4 py-2 bg-indigo-600 text-white rounded-md">${t('btnOK')}</button>
                </div>
            </div>`;
        
        const input = modal.querySelector('#promptInput');
        modal.querySelector('#promptOK').addEventListener('click', () => {
            onConfirm(input.value);
            closeModal();
        });
        modal.querySelector('#promptCancel').addEventListener('click', closeModal);
        modal.addEventListener('click', (e) => { if(e.target === modal) closeModal(); });
        
        modalContainer.appendChild(modal);
        input.focus();
        input.select();
    }

    function showExportModal() {
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.innerHTML = `
            <div class="modal-content">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-bold">${t('exportTitle')}</h2>
                    <button class="close-modal-btn text-gray-500 hover:text-gray-800 text-3xl">&times;</button>
                </div>
                <div class="space-y-4">
                    <div>
                        <label for="exportFileName" class="block text-sm font-medium text-gray-700">${t('labelFileName')}</label>
                        <input type="text" id="exportFileName" placeholder="${state.image.name || t('exportPlaceholder')}" class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    </div>
                    <div>
                        <label for="exportFormat" class="block text-sm font-medium text-gray-700">${t('labelExportFormat')}</label>
                        <select id="exportFormat" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                            <option value="png">PNG</option>
                            <option value="jpeg">JPEG</option>
                            <option value="webp">WebP</option>
                        </select>
                    </div>
                    <div>
                        <label for="exportSize" class="block text-sm font-medium text-gray-700"><span data-lang="labelExportSize">${t('labelExportSize')}</span>: <span id="exportSize-value">800</span>px</label>
                        <input type="range" id="exportSize" min="400" max="2000" step="100" value="800" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <button id="download-image-btn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">${t('btnExport')}</button>
                </div>
            </div>`;
        
        modal.querySelector('.close-modal-btn').addEventListener('click', closeModal);
        modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
        modal.querySelector('#exportSize').addEventListener('input', (e) => { modal.querySelector('#exportSize-value').textContent = e.target.value; });
        modal.querySelector('#download-image-btn').addEventListener('click', exportImage);
        
        modalContainer.appendChild(modal);
    }

    // --- ファイル操作 ---
    function showSaveModal() {
        const defaultName = state.image.name ? `${state.image.name}-Chart` : t('savePlaceholder');
        showPromptModal(t('labelFileName'), defaultName, (fileName) => {
            if (fileName) {
                saveChartData(sanitizeFileName(fileName));
            }
        });
    }

    function saveChartData(fileName) {
        const dataToSave = {
            version: '5.6',
            settings: state.settings, chartData: state.chartData,
            image: { dataUrl: state.image.element ? state.image.element.src : null, name: state.image.name, opacity: state.image.opacity, offsetX: state.image.offsetX, offsetY: state.image.offsetY, scale: state.image.scale },
            text: state.text, editMode: state.editMode,
        };
        const dataStr = JSON.stringify(dataToSave, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${fileName}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function loadChartData(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const loadedData = JSON.parse(event.target.result);
                validateAndApplyLoadedData(loadedData);
            } catch (error) {
                console.error("File loading failed:", error);
                showMessageModal(t('invalidFile'));
            }
        };
        reader.readAsText(file);
        getEl('load-input').value = '';
    }

    function validateAndApplyLoadedData(data) {
        isApplyingState = true;

        const defaultSettings = getDefaultSettings();
        const defaultText = getDefaultTextSettings();

        // Settings
        if (data.settings && typeof data.settings === 'object') {
            state.settings = { ...defaultSettings, ...data.settings };
            state.settings.sides = Math.max(4, Math.min(7, parseInt(state.settings.sides, 10) || 5));
            state.settings.maxValue = Math.max(4, Math.min(10, parseInt(state.settings.maxValue, 10) || 5));
        } else {
            state.settings = defaultSettings;
        }

        // ChartData
        if (data.chartData && typeof data.chartData === 'object' && Array.isArray(data.chartData.labels) && Array.isArray(data.chartData.values)) {
            if (data.chartData.labels.every(l => typeof l === 'string')) {
                 data.chartData.labels = data.chartData.labels.map(text => getDefaultLabel(text));
            }
            data.chartData.labels = data.chartData.labels.map(l => ({ ...getDefaultLabel(), ...l }));
            state.chartData = data.chartData;
        } else {
            state.chartData = { labels: [], values: [] };
            updateChartData(state.settings.sides); 
        }

        // Text
        if (data.text && typeof data.text === 'object') {
            state.text = { ...defaultText, ...data.text };
        } else {
            state.text = defaultText;
        }
        state.editMode = (data.editMode === 'text' || data.editMode === 'image') ? data.editMode : 'image';
        state.image = { element: null, name: '', opacity: 1.0, offsetX: 0, offsetY: 0, scale: 1.0 }; 

        const applyUIUpdates = () => {
            updateLanguage();
            updateSettingsUI();
            updateContainerBackground();
            updateEditViewUI();
            updateStatusLabelsUI();
            resizeCanvas();
            isApplyingState = false;
        };

        if (data.image && typeof data.image === 'object' && data.image.dataUrl && String(data.image.dataUrl).startsWith('data:image/')) {
            const img = new Image();
            img.onload = () => {
                state.image = { ...state.image, ...data.image, element: img, scale: data.image.scale || 1.0 };
                applyUIUpdates();
                draw();
                saveStateToHistory();
            };
            img.onerror = () => {
                applyUIUpdates();
                draw();
                saveStateToHistory();
            }
            img.src = data.image.dataUrl;
        } else {
            applyUIUpdates();
            draw();
            saveStateToHistory();
        }
    }

    function exportImage() {
        const fileNameInput = getEl('exportFileName');
        let fileName = fileNameInput.value.trim() || fileNameInput.placeholder;
        fileName = sanitizeFileName(fileName);
        const format = getEl('exportFormat').value;
        const size = parseInt(getEl('exportSize').value);
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = size;
        tempCanvas.height = size;
        
        const tempCtx = tempCanvas.getContext('2d');
        const geometry = calculateGeometry(tempCanvas.width, tempCanvas.height);
        
        drawBackground(tempCtx, tempCanvas.width, tempCanvas.height, {
            forceOpaqueBackground: format === 'jpeg'
        });
        drawOnContext(tempCtx, tempCanvas.width, tempCanvas.height, geometry);

        const imageType = `image/${format}`;
        const dataUrl = tempCanvas.toDataURL(imageType, format === 'jpeg' ? 0.9 : 1.0);
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = `${fileName}.${format}`;
        a.click();
        
        closeModal();
    }
    
    // --- ヘルパー関数 ---
    function hexToRgba(hex, alpha) {
        let r = 0, g = 0, b = 0;
        if (hex.length == 4) { r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3]; }
        else if (hex.length == 7) { r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6]; }
        return `rgba(${+r},${+g},${+b},${alpha})`;
    }

    function sanitizeFileName(fileName) {
        return fileName.replace(/[\/\\?%*:|"<>]/g, '-');
    }

    // --- Undo/Redo ---
    function saveStateToHistory() {
        if (isApplyingState) return;
        
        history = history.slice(0, historyIndex + 1);
        
        const newState = JSON.parse(JSON.stringify(state, (key, value) => {
            if (key === 'element') return null;
            return value;
        }));
        if(state.image.element) {
            newState.image.dataUrl = state.image.element.src;
        }

        history.push(newState);
        historyIndex = history.length - 1;
    }

    function applyState(stateToApply) {
        isApplyingState = true;
        
        const imageElement = state.image.element;
        state = JSON.parse(JSON.stringify(stateToApply));
        
        if (stateToApply.image.dataUrl) {
            if (!imageElement || imageElement.src !== stateToApply.image.dataUrl) {
                const img = new Image();
                img.onload = () => {
                    state.image.element = img;
                    draw();
                };
                img.src = stateToApply.image.dataUrl;
            } else {
                 state.image.element = imageElement;
            }
        } else {
            state.image.element = null;
        }

        updateSettingsUI();
        updateContainerBackground();
        updateEditViewUI();
        updateStatusLabelsUI();
        resizeCanvas();
        
        isApplyingState = false;
    }

    function undo() {
        if (historyIndex > 0) {
            historyIndex--;
            applyState(history[historyIndex]);
        }
    }

    function redo() {
        if (historyIndex < history.length - 1) {
            historyIndex++;
            applyState(history[historyIndex]);
        }
    }
    
    // --- Fullscreen ---
    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    function updateFullscreenButton() {
        const btn = getEl('fullscreen-btn');
        if(!btn) return;
        const icon = btn.querySelector('i');
        if (document.fullscreenElement) {
            icon.classList.remove('fa-expand');
            icon.classList.add('fa-compress');
            btn.title = t('fullscreenExit');
        } else {
            icon.classList.remove('fa-compress');
            icon.classList.add('fa-expand');
            btn.title = t('fullscreenEnter');
        }
    }

    init();
};
</script>

</body>
</html>

